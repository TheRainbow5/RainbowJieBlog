<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo安装运行</title>
    <url>/2023/11/07/Hexo/Hexo%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="安装-Node-js-和-Git"><a href="#安装-Node-js-和-Git" class="headerlink" title="安装 Node.js 和 Git"></a><strong>安装 Node.js 和 Git</strong></h2><p>确保你的系统上已经安装了 Node.js 和 Git。你可以从它们的官方网站上下载并安装：</p>
<ol>
<li><a class="link"   href="https://nodejs.org/" >Node.js 官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://git-scm.com/" >Git 官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a><strong>安装 Hexo</strong></h2><p>安装完成 Node.js 和 Git 后，在命令行中使用 npm（Node.js 的包管理器）安装 Hexo。打开命令行工具（Terminal 或 Command Prompt）并运行以下命令：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></div>

<h2 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a><strong>创建博客</strong></h2><p>选择一个合适的目录位置，在命令行中执行以下命令来创建一个新的 Hexo 博客：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init myblog</span><br><span class="line"><span class="built_in">cd</span> myblog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></div>

<h2 id="运行博客"><a href="#运行博客" class="headerlink" title="运行博客"></a><strong>运行博客</strong></h2><p>在博客目录下执行以下命令启动本地服务器：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></div>

<p>这将启动一个本地服务器，显示博客的预览。访问 <a class="link"   href="http://localhost:4000/" >http://localhost:4000/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 可以查看你的博客。</p>
<h2 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a><strong>创建新文章</strong></h2><p>使用以下命令创建一篇新文章：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>这将在 <strong><code>source/_posts</code></strong> 目录中创建一个新的 Markdown 文件，用于撰写你的新文章。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-注解（Annotation）</title>
    <url>/2023/11/07/Java/Advanced-Application/Java-%E6%B3%A8%E8%A7%A3Annotation/</url>
    <content><![CDATA[<h2 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h2><p>**<code>@Override</code>**它用于标记一个方法是要覆盖（重写）父类或接口中的方法。</p>
<p>该注解只能用于方法</p>
<p>Code：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from Parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from Child&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>如果子类没有添加@Override注解，还是会重写父类的方法</li>
<li>写了@Override注解，编译器会检查该防范是否真的重写了父类的方法，是则编译成功，反之报错。</li>
</ol>
<p>Source Code：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span>         </span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;  </span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>**<code>@Target(ElementType.METHOD)</code>**：</p>
<ol>
<li>@Target 注解用于指定自定义注解可以应用的目标元素类型；修饰注解的注解（元注解）</li>
<li>@Target(ElementType.METHOD) 表示这个自定义注解只能应用到方法（Method）上。</li>
</ol>
</li>
<li><p>**<code>@Retention(RetentionPolicy.SOURCE)</code>**：</p>
<ol>
<li>@Retention 注解用于指定自定义注解的保留策略，即注解在何时可见。</li>
<li>@Retention(RetentionPolicy.SOURCE) 表示这个注解只在源代码级别可见，编译后不会包含在编译后的 .class 文件中。</li>
</ol>
</li>
<li><p>**<code>public @interface Override</code>**：</p>
<ol>
<li>public 表示这个自定义注解是公共的，可以在其他包中使用。</li>
<li>@interface 关键字用于定义一个自定义注解。</li>
<li>这个注解的名字是 Override，与Java语言中的 @Override 注解同名，但它们不同。</li>
</ol>
</li>
</ol>
<h2 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h2><p><strong><code>@Deprecated</code></strong> 注解是Java语言中的一个预定义注解（annotation），它用于标记一个类、方法、字段或其他元素已被废弃，不推荐继续使用。</p>
<p><strong>Code</strong>：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeprecatedExample</span> &#123;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deprecatedMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 一些过时的操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 新的操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeprecatedExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeprecatedExample</span>();</span><br><span class="line">        <span class="comment">// 调用过时的方法，会产生编译警告</span></span><br><span class="line">        example.deprecatedMethod();</span><br><span class="line">        <span class="comment">// 调用新的方法，没有问题</span></span><br><span class="line">        example.newMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>Source Code</strong>：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><strong><code>@Documented</code></strong> 注解表示该注解应该被包含在Java文档中。</li>
<li><strong><code>@Retention(RetentionPolicy.RUNTIME)</code></strong> 注解表示这个注解在运行时可用。</li>
<li><strong><code>@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</code></strong> 注解：<ol>
<li>这里指定了多种目标元素类型，包括构造方法（CONSTRUCTOR）、字段（FIELD）、局部变量（LOCAL_VARIABLE）、方法（METHOD）、包（PACKAGE）、参数（PARAMETER）和类型（TYPE）。</li>
</ol>
</li>
</ol>
<h2 id="SuppressWarning"><a href="#SuppressWarning" class="headerlink" title="@SuppressWarning"></a>@SuppressWarning</h2><p>当我们不希望看到相关警告，可以使用**<code>@SuppressWarning</code>**注解来一直警告信息</p>
<p><strong>Code</strong>：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">// 未经检查的转换警告</span></span><br><span class="line">    myList.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    myList.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> myList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useDeprecatedMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    SomeDeprecatedClass.deprecatedMethod(); <span class="comment">// 废弃 API 使用警告</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useRawType</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">// 直接作用在变量上，原始类型警告</span></span><br><span class="line">    myList.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    myList.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>常见的参数</strong>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td>用于抑制所有类型的警告。这个参数应该慎用，因为它会抑制所有警告，包括潜在的问题。</td>
</tr>
<tr>
<td>rawtypes</td>
<td>用于抑制原始类型警告。原始类型警告通常在使用泛型时没有指定类型参数时出现。</td>
</tr>
<tr>
<td>deprecation</td>
<td>用于抑制废弃 API 使用警告。这种警告会在使用已被标记为废弃的方法或类时出现。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>Source Code</strong>：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD,</span></span><br><span class="line"><span class="meta">				 ElementType.PARAMETER, ElementType.CONSTRUCTOR, ElementType.LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>需要注意的是，使用 <strong><code>@SuppressWarnings</code></strong> 注解应该谨慎，并且应该仅在确定警告是安全的、没有更好的解决方案时使用。</p>
<p>滥用这个注解可能会掩盖潜在的问题。</p>
<h2 id="Annotation（元注解）"><a href="#Annotation（元注解）" class="headerlink" title="Annotation（元注解）"></a>Annotation（元注解）</h2><p>常见注解种类：</p>
<ol>
<li>@Retention：指定注解的作用范围（SOURCE、CLASS、RUNTIME）</li>
<li>@Target：指定注解可以在哪些代码元素（方法、属性等）使用</li>
<li>@Documented：指定该注解是否会在javadoc体现</li>
<li>@Inherited：子类会继承父类注解</li>
</ol>
<h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p>它用来指定注解的保留策略。在 Java 中，注解可以有三种保留策略，分别是：</p>
<ol>
<li>**<code>RetentionPolicy.SOURCE</code>**：这种保留策略表示注解仅在源代码级别存在，编译成字节码文件后就被丢弃，不会包含在编译后的类文件和运行时环境中。</li>
<li>**<code>RetentionPolicy.CLASS</code>**：这种保留策略表示注解会被保留到编译后的类文件中，但在运行时不可访问。这是默认的保留策略。</li>
<li><strong><code>RetentionPolicy.RUNTIME</code><strong>：这种保留策略表示注解会被保留到编译后的类文件中，并且可以在运行时通过</strong>反射机制</strong>访问。这允许在运行时动态处理注解信息。</li>
</ol>
<p><strong>Code</strong>：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">// 注解的定义内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上述代码采用了运行时保留策略，可以在运行时通过反射访问该注解的内容。</p>
<h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p>它用来指定自定义注解可以应用的目标元素，即注解可以放在哪些程序元素上</p>
<ol>
<li>**<code>ElementType.TYPE</code>**：可以用在类、接口、枚举类型上。</li>
<li>**<code>ElementType.FIELD</code>**：可以用在字段（成员变量）上。</li>
<li>**<code>ElementType.METHOD</code>**：可以用在方法上。</li>
<li>**<code>ElementType.PARAMETER</code>**：可以用在方法的参数上。</li>
<li>**<code>ElementType.CONSTRUCTOR</code>**：可以用在构造函数上。</li>
<li>**<code>ElementType.LOCAL_VARIABLE</code>**：可以用在局部变量上。</li>
<li>**<code>ElementType.ANNOTATION_TYPE</code>**：可以用在注解上。</li>
<li>**<code>ElementType.PACKAGE</code>**：可以用在包上。</li>
</ol>
<p>Code：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">// 注解的定义内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><p>@Documented 注解表示该注解应该被包含在Java文档中。</p>
<h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p>如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/09/28/Hexo/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-常用类（Common Classes）</title>
    <url>/2023/11/07/Java/Advanced-Application/Java-%E5%B8%B8%E7%94%A8%E7%B1%BBCommon-Classes/</url>
    <content><![CDATA[<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>针对八种基本数据类型相应的引用类型</p>
<p>Boolean、Character</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/21.png"
                      alt="Alt text"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/22.png"
                      alt="Alt text"
                ></p>
<h3 id="包装类和基本数据的转换"><a href="#包装类和基本数据的转换" class="headerlink" title="包装类和基本数据的转换"></a>包装类和基本数据的转换</h3><ol>
<li><p><strong>装箱（Boxing）</strong></p>
<p> 装箱是将基本数据类型转为对应的包装类对象的过程，可以直接通过赋值或者方法调用</p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">primitiveInt</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">wrapperInt</span> <span class="operator">=</span> primitiveInt; <span class="comment">// 自动装箱  底层使用的是Integer.valueOf(primitiveInt)</span></span><br><span class="line"></span><br><span class="line">或者显示装箱</span><br><span class="line"><span class="type">int</span> <span class="variable">primitiveInt</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">wrapperInt</span> <span class="operator">=</span> Integer.valueOf(primitiveInt); <span class="comment">// 手动装箱</span></span><br><span class="line"></span><br><span class="line">字符串转为包装类</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">wrapperInt</span> <span class="operator">=</span> Integer.valueOf(str);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>拆箱（Unboxing）</strong></p>
<p> 拆箱是将包装类对象转为基本数据类型的过程，它可以直接通过赋值或者方法调用完成</p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">wrapperInt</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">primitiveInt</span> <span class="operator">=</span> wrapperInt; <span class="comment">// 自动拆箱</span></span><br><span class="line"></span><br><span class="line">或者显示的拆箱</span><br><span class="line"><span class="type">Integer</span> <span class="variable">wrapperInt</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">primitiveInt</span> <span class="operator">=</span> wrapperInt.intValue(); <span class="comment">// 手动拆箱</span></span><br><span class="line"></span><br><span class="line">包装类转为字符串</span><br><span class="line"><span class="type">Integer</span> <span class="variable">wrapperInt</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> wrapperInt.toString();</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p><strong>Integer.valueOf（int）</strong>底层源码</p>
<p>Integer.valueOf(int) 方法是用于将一个 int 值转换为对应的 Integer 对象的静态方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);   <span class="comment">//超过范围后，才会重新new一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>首先检查给定的数字是否在$[-128，127]$范围之内；</li>
<li>如果在这个范围之内，就会从缓存中获取Integer对象，而不是创建一个对象，这样可以减少对象的创建和内存消耗；</li>
<li>如果不在这个范围之内，就会创建一个新的Integer对象。</li>
</ol>
<p>例如：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>); </span><br><span class="line"><span class="type">Integer</span> <span class="variable">num2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>); </span><br><span class="line">System.out.println(num1==num2);    <span class="comment">//true，都指向同一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">128</span>); </span><br><span class="line"><span class="type">Integer</span> <span class="variable">num2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">128</span>); </span><br><span class="line">System.out.println(num1==num2);    <span class="comment">//false，由于超过除了缓存范围，创建一个新Integer对象</span></span><br></pre></td></tr></table></figure></div>

<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String对象是用于保存字符串，也就是字符序列；</p>
<p>字符串常量对象使用双引号括起来的字符序列，例如：“你好”、“12.97”；</p>
<p>字符串的字符使用Unicode字符编码，<strong>一个字符占两个字节</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/23.png"
                      alt="Alt text"
                ></p>
<p>Serializable：子类可以实现串行化，可以在网络传输；</p>
<p>Comparable：子类可以比较；</p>
<p><strong>常见的构造器</strong>：</p>
<ol>
<li>String (String)：直接通过字符串创建</li>
<li>String (char[])：使用字符数组创建字符串</li>
<li>String (char[], int, int)：使用字符数组的一部分来创建一个字符串对象。第二个参数是起始索引，第三个参数是子数组的长度。</li>
<li>String (byte[])：接受一个字节数组来创建一个字符串对象</li>
<li>String (byte[], int ,int)：使用字节数组的一部分来创建一个字符串对象。第二个参数是起始索引，第三个参数是子数组的长度。</li>
</ol>
<p><strong>特性</strong>：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">String str1=<span class="string">&quot;hello&quot;</span>;   <span class="comment">//对象存放在常量池中</span></span><br><span class="line">String str2=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>)  <span class="comment">//对象存放在堆中</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/24.png"
                      alt="Alt text"
                ></p>
<ol>
<li>String是$final$修饰的类，无法被其他类继承；</li>
<li>字符串是不可变的，一个字符串对象一旦被分配，其内容就无法修改</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">String s1=<span class="string">&quot;hello&quot;</span></span><br><span class="line">s1=<span class="string">&quot;hahah&quot;</span></span><br><span class="line">在方法区的常量池中，实际上创建了两个对象：hello、hahah</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">String a=<span class="string">&quot;hello&quot;</span>+<span class="string">&quot;world&quot;</span>;  实际上只创建了一个对象：helloworld</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">String str1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str2=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">String str4=str1+str2;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>当执行<code>String str4 = str1 + str2</code>，Java编译器会使用<code>StringBuilder</code>类来处理字符串的拼接。</li>
<li>StringBuilder s&#x3D;new StringBuilder()对象，str1、str2的内容会复制到StringBuilder的缓存区中；</li>
<li>sb.append(str1)、sb.append(str2)；</li>
<li>String str4&#x3D;sb.toString()；底层实际上是在<strong>堆</strong>中创建了一个对象；</li>
</ol>
<p>最后在常量池中创建了两个对象：hello、world，在堆中创建了一个对象：helloworld。</p>
<h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/25.png"
                      alt="Alt text"
                ></p>
<ol>
<li><p>StringBuffer的直接父类是AbstractStringBuilder；</p>
</li>
<li><p>实现了Serializable接口，对象可以串行化；</p>
</li>
<li><p>在父类中，AbstractStringBuilder有属性<code>char[] value</code>，用于存储字符，不是final修饰；<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/26.png"
                      alt="Alt text"
                ></p>
</li>
<li><p>StringBuffer是一个$final$类，无法被继承<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/27.png"
                      alt="Alt text"
                ></p>
</li>
</ol>
<p><strong>StringBuffer VS String</strong></p>
<ol>
<li>String保存的字符串常量，每次更新String类就是更改地址，效率低。</li>
<li>StringBuffer保存的是字符串变量存放在char[]数组，内容可以更改，不用每次更新地址（创建新对象），效率高。</li>
</ol>
<p><strong>常见构造器</strong>：</p>
<ol>
<li><code>new StringBuffer()</code>：无参数构造方法，创建一个空的 StringBuffer 对象，初始容量为 16 个字符。</li>
<li><code>new StringBuffer(int capacity)</code>：带有容量参数的构造方法，创建一个具有指定容量的 StringBuffer 对象。如果预计字符串将比较长，可以指定一个较大的容量以避免频繁的扩容操作。</li>
<li><code>new StringBuffer(String str)</code>：创建一个包含指定字符串内容的 StringBuffer 对象，初始容量为 <code>str.length() + 16</code>。</li>
</ol>
<p><strong>源码分析</strong>：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>初始化char[]数组的容量为**<code>str.length() + 16</code>**<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/28.png"
                      alt="Alt text"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/29.png"
                      alt="Alt text"
                ></p>
</li>
<li><p>执行append方法，将字符串添加到char[]数组，可以看到<code>append(String str)</code>方法被$synchronized$修饰，所以StringBuffer是<strong>线程安全</strong>的。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/30.png"
                      alt="Alt text"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/31.png"
                      alt="Alt text"
                ></p>
</li>
<li><p>最后完成数据存储<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/32.png"
                      alt="Alt text"
                ></p>
</li>
</ol>
<p><strong>常见方法</strong>：</p>
<ol>
<li>**append(String str)**：将指定的字符串附加到当前字符串的末尾。</li>
<li>**insert(int offset, String str)**：在指定的偏移量位置插入指定的字符串。</li>
<li>**delete(int start, int end)**：删除从指定开始位置到结束位置之间的字符。</li>
<li>**deleteCharAt(int index)**：删除指定索引位置的字符。</li>
<li>**replace(int start, int end, String str)**：用指定的字符串替换从开始位置到结束位置之间的字符。</li>
<li>**substring(int start)**：返回从指定位置开始到字符串末尾的子字符串。。</li>
<li>**length()**：返回字符串的长度（字符数）。</li>
<li>**charAt(int index)**：返回指定索引位置的字符。</li>
</ol>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>一个可变的字符序列。</p>
<p>StringBuilder是线程不安全的，用在字符串缓冲区被<strong>单个线程</strong>使用的时候。</p>
<p><strong>父类关系图</strong>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/33.png"
                      alt="Alt text"
                ></p>
<ol>
<li>StringBuilder的直接父类是AbstractStringBuilder；</li>
<li>实现了Serializable接口，对象可以串行化（对象可以网络传输&#x2F;保存到文件）；</li>
</ol>
<p><strong>源码分析</strong>：</p>
<ol>
<li><p>StringBuilder是final类，无法被继承；<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/34.png"
                      alt="Alt text"
                ></p>
</li>
<li><p>字符序列存放AbstractStringBuilder的char[] value数组，因此存放在堆中。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/35.png"
                      alt="Alt text"
                ></p>
</li>
<li><p>StringBuilder所有的方法没有互斥处理（synchronized），因此推荐在单线程的情况下使用；<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/36.png"
                      alt="Alt text"
                ></p>
</li>
</ol>
<h2 id="String-VS-StringBuffer-VS-StringBuilder"><a href="#String-VS-StringBuffer-VS-StringBuilder" class="headerlink" title="String VS StringBuffer VS StringBuilder"></a>String VS StringBuffer VS StringBuilder</h2><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>效率</th>
<th>优点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>不可变的字符序列</td>
<td>低</td>
<td>复用率高</td>
<td>字符串很少修改</td>
</tr>
<tr>
<td>StringBuffer</td>
<td>可变的字符序列</td>
<td>较高</td>
<td>线程安全</td>
<td>字符串存在大量修改，并在多线程</td>
</tr>
<tr>
<td>StringBuilder</td>
<td>可变的字符序列</td>
<td>最高（单线程）</td>
<td>线程不安全</td>
<td>字符串存在大量修改，并在单线程</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL-约束Constraint</title>
    <url>/2023/11/12/Mysql/Advanced/MYSQL-%E7%BA%A6%E6%9D%9FConstraint/</url>
    <content><![CDATA[<p>MySQL支持多种类型的约束，这些约束可以应用于表的列上，以限制存储在列中的数据。</p>
<p><strong>常见的约束类型</strong>：</p>
<table>
<thead>
<tr>
<th>Primairy Key Constraint</th>
<th>Unique Constraint</th>
<th>Not NULL Constraint</th>
<th>Foreign Constraint</th>
<th>Check Constraint</th>
<th>Default Key Constraint</th>
<th>Auto Increament</th>
</tr>
</thead>
</table>
<p>详细说明如下：</p>
<ol>
<li><p><strong>Primary Key Constraint（主键约束）</strong></p>
<ol>
<li>主键约束用于唯一标识表中的每一行；</li>
<li>保证列中的元素是唯一的；</li>
<li>可以将主键约束应用到一个或多个列上；</li>
</ol>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,     #定义为表的主键</span><br><span class="line">	name <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>Unique Constraint（唯一性约束）</strong></p>
<ol>
<li>确保列中的值是唯一的，允许空值；</li>
<li>可以将唯一性约束应用到多个列；</li>
</ol>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">UNIQUE</span>,       #定义id属性是唯一的</span><br><span class="line">	name <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>Foreign Key Constraint（外键约束）</strong></p>
<ol>
<li>外键约束用于确保两个表之间的关系完整性；</li>
<li>确保一个表的列值与另一个表的主键列值相匹配；</li>
</ol>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,     #定义为表的主键</span><br><span class="line">	name <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">	<span class="keyword">FOREIGN</span> KEY (name) <span class="keyword">REFERENCES</span> Name(name)  #定义name属性是Name表中的主键，用于关联students表和Name表</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>Check Constraint（检查约束）</strong></p>
<ol>
<li>检查约束用于强制列中的值符合指定自定义的条件；</li>
</ol>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,     #定义为表的主键</span><br><span class="line">	age <span class="type">INT</span>,</span><br><span class="line">	name <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">	<span class="keyword">CHECK</span> (age <span class="operator">&gt;=</span> <span class="number">0</span>)        #定义age必须大于<span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>Default Constraint（默认约束）</strong></p>
<ol>
<li>用于在未提供之的情况下分配默认值；</li>
</ol>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products (</span><br><span class="line">    product_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    product_name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;Unknown&#x27;</span>  #定义控制用“<span class="literal">Unknown</span>”代替</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>Not Null Constraint（非空约束）</strong></p>
<ol>
<li>确保列中的值不为空</li>
<li>通常是用<code>**NOT NULL**</code>属性定义</li>
</ol>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,           #定义为表的主键</span><br><span class="line">	name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,   #定义name列不为空</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>Auto Increment（自增长）</strong></p>
<ol>
<li>允许自动分配唯一数值，确保每一行都有唯一标识；</li>
<li>通常是用<code>**AUTO_NCREMENT**</code>属性来义；</li>
<li>修饰的字段是整形，默认从1开始；</li>
</ol>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products (</span><br><span class="line">    product_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_NCREMENT,</span><br><span class="line">    product_name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;Unknown&#x27;</span>  #定义控制用“<span class="literal">Unknown</span>”代替</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div></li>
</ol>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL-索引Index</title>
    <url>/2023/11/12/Mysql/Advanced/MYSQL-%E7%B4%A2%E5%BC%95Index/</url>
    <content><![CDATA[<h2 id="为什么有索引？"><a href="#为什么有索引？" class="headerlink" title="为什么有索引？"></a>为什么有索引？</h2><p>在MySql数据库中，索引是用于加快数据检索操作的数据结构。<br>索引允许数据库管理系统快速的定位数据的行，而无需扫描整个表。</p>
<h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>现一张sutdent表，有800万条数据，</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students(</span><br><span class="line">	id <span class="type">INT</span>  AUTO_INCREMENT,   </span><br><span class="line">	name VARCAHR(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,         <span class="operator">/</span><span class="operator">/</span>name不为空</span><br><span class="line">	age <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,                    <span class="operator">/</span><span class="operator">/</span>age不为空，且大于<span class="number">0</span></span><br><span class="line">	<span class="keyword">CHECK</span> (age<span class="operator">&gt;=</span><span class="number">0</span>)      </span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>此时<code>**students.ibd**</code>数据文件的大小为523M。</p>
<ol>
<li><p>查询id&#x3D;50万这条数据</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">500000</span>;</span><br><span class="line"></span><br><span class="line">查询时间<span class="operator">=</span><span class="number">4.35</span>秒</span><br></pre></td></tr></table></figure></div>
<p> 对于计算机来说，查询一条数据需要花费4.35秒是完全不能接受的。此时，就可以使用索引来优化查询。</p>
</li>
<li><p>创建索引，查询id&#x3D;500万这条数据</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX age_index <span class="keyword">on</span> student(age)   <span class="operator">/</span><span class="operator">/</span>创建id属性的索引</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">查询时间<span class="operator">=</span><span class="number">0.003</span>秒</span><br></pre></td></tr></table></figure></div>
<p> 创建索引后，此时<code>**students.ibd**</code>数据文件的大小为634M，说明索引占用一定量的空间。</p>
<p> 使用索引后，在不用加内存、修改程序、调整sql的情况下，查询的效率得到了质的飞跃。</p>
 <aside>
 💡 **MySql只对创建了索引的列进行查询，才能使用索引提高效率。**
 
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">查询时间<span class="operator">=</span><span class="number">4.35</span>秒</span><br></pre></td></tr></table></figure></div>
<p> 此时，查询仍是4.35秒。</p>
 </aside></li>
</ol>
<h2 id="索引的机制"><a href="#索引的机制" class="headerlink" title="索引的机制"></a>索引的机制</h2><table>
<thead>
<tr>
<th>类型</th>
<th>速度</th>
<th>机制</th>
<th>空间</th>
<th>局限</th>
</tr>
</thead>
<tbody><tr>
<td>普通检索</td>
<td>慢</td>
<td>线性扫描每一行数据</td>
<td>不占用空间</td>
<td></td>
</tr>
<tr>
<td>索引检索</td>
<td>超快</td>
<td>数据索引结构为二叉树</td>
<td>需要占用空间</td>
<td>对delet、update、insert会速度有一定的影响</td>
</tr>
</tbody></table>
<p>详细说明如下。</p>
<h3 id="普通检索机制"><a href="#普通检索机制" class="headerlink" title="普通检索机制"></a>普通检索机制</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">50</span>;</span><br></pre></td></tr></table></figure></div>

<p>在没有查询没有索引的数据时，数据库系统查询的机制是线性s扫描每一行元素</p>
<p>知道满足查询条件为止，查询速度慢。如下如所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images%5CMYSQL%5C1.webp"
                      alt="Alt text"
                ></p>
<h3 id="索引检索机制"><a href="#索引检索机制" class="headerlink" title="索引检索机制"></a>索引检索机制</h3><p>现在对id属性创建索引，数据库系统会形成一个数据结构，比如<strong>二叉树</strong>、B**+树**等等，如下如所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images%5CMYSQL%5C2.webp"
                      alt="Alt text"
                ></p>
<p>如果我们比较了3次，覆盖的表范围：$2^3&#x3D;8$。</p>
<p><strong>局限性：</strong></p>
<p>虽然索引对于Select语句的查询速度有着质的飞跃，但是对<code>update、insert、delete</code>速度有一定的影响。</p>
<p>这里以delete操作为例：</p>
<p>当执行了delete操作后，数据的删除导致索引的结构就会发生改变，如下如所示:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images%5CMYSQL%5C3.webp"
                      alt="Alt text"
                ></p>
<p>insert、delete同理。</p>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p>MySql支持多种类型的索引，以下是常用的索引类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>适用范围</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引（UNIQUE）</td>
<td>用于唯一标识表中的每一行，本身就是索引</td>
<td>列的数据没有重复</td>
</tr>
<tr>
<td>普通索引（INDEX）</td>
<td>用于普通检索操作</td>
<td>列的数据重复</td>
</tr>
<tr>
<td>全文索引（FALLTEXT）</td>
<td>用于全文搜索，适用于MyISAM引擎，但是效率较低，开发中不使用，而是使用ElasticSearch</td>
<td></td>
</tr>
</tbody></table>
<p>详细说明如下。</p>
<ol>
<li><p><strong>主键索引（UNIQUE）</strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,   <span class="operator">/</span><span class="operator">/</span>主键自增长</span><br><span class="line">	name VARCAHR(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,         <span class="operator">/</span><span class="operator">/</span>name不为空</span><br><span class="line">	age <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,                    <span class="operator">/</span><span class="operator">/</span>age不为空，且大于<span class="number">0</span></span><br><span class="line">	<span class="keyword">CHECK</span> (age<span class="operator">&gt;=</span><span class="number">0</span>)      </span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>
<p> 在创建主键时，主键本身就是一种索引，所以在根据id查询数据时，速度很快。</p>
<p> id是唯一的，同时也是索引，成为unique索引。</p>
</li>
<li><p><strong>全文索引（FALLTEXT）</strong></p>
<p> 用于全文搜索，一段文章的字段上建立索引。</p>
<p> 适用于MyISAM引擎，但是效率较低，开发中不使用，而是使用ElasticSearch。</p>
</li>
</ol>
<h2 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h2><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEXES <span class="keyword">FROM</span> [表名]</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> [表名]</span><br><span class="line"></span><br><span class="line"><span class="keyword">DESC</span> [表名]</span><br></pre></td></tr></table></figure></div>

<h3 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h3><ol>
<li><p>添加唯一索引</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX id_index <span class="keyword">on</span> student(id);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>添加普通索引</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX id_index <span class="keyword">on</span> student(id);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>添加主键索引</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,   <span class="operator">/</span><span class="operator">/</span>主键自增长，指定为主键</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>alter</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ADD</span> INDEX id_index (id)</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><ol>
<li><p>使用<code>DROP INDEX</code>语句删除索引：</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX id_index <span class="keyword">ON</span> student;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>使用<code>ALTER TABLE</code>语句删除索引：</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">DROP</span> INDEX id_index</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>删除主键索引</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h1 id="使用索引的情况？"><a href="#使用索引的情况？" class="headerlink" title="使用索引的情况？"></a>使用索引的情况？</h1><p><strong>适合</strong></p>
<ol>
<li>频繁作为查询条件字段，适合创建索引；</li>
</ol>
<p><strong>不适合</strong></p>
<ol>
<li>唯一性太差的字段，不适合创建索引；</li>
<li>更新十分频繁的字段，不适合创建索引；</li>
<li>不会出现在where子句的字段，不适合创建索引；</li>
</ol>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL-分页查询</title>
    <url>/2023/11/11/Mysql/Basic/MYSQL-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="为什么有分页？"><a href="#为什么有分页？" class="headerlink" title="为什么有分页？"></a>为什么有分页？</h2><ol>
<li><strong>性能优化</strong>：<ol>
<li>对于大型数据库，一次性检索整个数据集可能会占用较多系统资源，导致查询速度变慢。</li>
<li>通过分页，可以减少每次检索的数据量，减轻数据库负担，提高性能。</li>
</ol>
</li>
<li><strong>减少网络流量</strong>：<ol>
<li>对于需要通过网络传输的应用，分页可以减少每次数据传输的量，节省带宽，提高加载速度。</li>
</ol>
</li>
<li><strong>快速定位</strong>：<ol>
<li>分页提供做快速定位数据的能力。</li>
<li>用户可以直接跳到特定的位置而无需检索整个表。</li>
</ol>
</li>
</ol>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 MySQL 中，分页操作是通过使用 <code>**LIMIT**</code> 和 <code>**OFFSET**</code> 来实现的。这两个关键字结合可以帮助你从查询结果中选择特定的行，以实现分页效果。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">LIMIT number_of_rows <span class="keyword">OFFSET</span> offset_value;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>number_of_rows：表示需要检索的行数</li>
<li>offset_value：表示从结果集的起始位置开始跳过的行数。</li>
</ol>
<h3 id="分页查询的不同方法"><a href="#分页查询的不同方法" class="headerlink" title="分页查询的不同方法"></a><strong><strong>分页查询的不同方法</strong></strong></h3><ol>
<li><p><strong>LIMIT OFFSET 分页</strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users</span><br><span class="line">LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">10</span>; <span class="comment">-- 获取第二页，每页10条记录</span></span><br></pre></td></tr></table></figure></div>
<p> 该语句会跳过前10条记录，然后获取接下来的10条记录，模拟分页的效果。</p>
</li>
<li><p><strong>使用LIMIT分页</strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users</span><br><span class="line">LIMIT <span class="number">20</span>, <span class="number">10</span>; <span class="comment">-- 获取第三页，每页10条记录</span></span><br></pre></td></tr></table></figure></div>
<p> 这种方法中，**<code>LIMIT</code>** 接受两个参数，第一个参数是偏移量（从0开始的索引），第二个参数是需要返回的行数。</p>
</li>
</ol>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>当数据量非常大时，使用 <strong><code>LIMIT</code></strong> 和 <strong><code>OFFSET</code></strong> 可能会导致性能问题。</p>
<p>在大型数据集上，使用这种方法会导致 MySQL 必须扫描和跳过大量的行。为了解决这个问题，可以使用以下技巧：</p>
<ol>
<li><strong>游标（Cursor）</strong>：通过记录上一次查询的最后一个元素，来实现基于游标的分页查询。</li>
<li><strong>基于主键的分页</strong>：如果按照主键顺序进行分页查询，可以提高效率。比如，如果主键是自增ID，可以使用 <strong><code>WHERE id &gt; last_id</code></strong> 的方式来获取下一页数据。</li>
<li><strong>使用子查询</strong>：在某些情况下，子查询可以提高效率，因为它可以减少跳过的行数。</li>
</ol>
<h3 id="游标分页的工作原理"><a href="#游标分页的工作原理" class="headerlink" title="游标分页的工作原理"></a>游标分页的工作原理</h3><ol>
<li><p><strong>游标声明</strong></p>
<p> 首先，你需要声明一个游标来指向查询的结果集。在 MySQL 中，游标通常用于存储过程或函数中。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span>   <span class="operator">/</span><span class="operator">/</span>声明游标</span><br><span class="line"><span class="keyword">SELECT</span> column1, column2</span><br><span class="line"><span class="keyword">FROM</span> your_table</span><br><span class="line"><span class="keyword">WHERE</span> conditions</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> some_column;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>打开游标</strong></p>
<p> 一旦声明了游标，你需要打开它以准备处理数据。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> cursor_name;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>逐行检索数据</strong></p>
<p> 使用 <strong><code>FETCH</code></strong> 语句从游标中逐行检索数据。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> cursor_name <span class="keyword">INTO</span> variable1, variable2;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>处理检索到的数据</strong></p>
<p> 当使用 <strong><code>FETCH</code></strong> 语句检索数据后，可以对数据执行相应的处理操作。</p>
</li>
<li><p><strong>关闭游标</strong></p>
<p> 最后，在完成数据检索后，关闭游标。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> cursor_name;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>在游标分页中，通常使用游标来逐行获取数据，结合条件进行分页操作。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span>    <span class="operator">/</span><span class="operator">/</span>声明游标</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2</span><br><span class="line"><span class="keyword">FROM</span> your_table</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> some_column</span><br><span class="line">LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">20</span>; <span class="comment">-- 以 OFFSET 和 LIMIT 实现分页</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">OPEN</span> cursor_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">FETCH</span> cursor_name <span class="keyword">INTO</span> variable1, variable2; <span class="comment">-- 检索第一页数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 逐行处理数据</span></span><br><span class="line"><span class="comment">-- 处理完一行后，再次 FETCH，继续处理下一行数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CLOSE</span> cursor_name;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL-基本查询</title>
    <url>/2023/11/10/Mysql/Basic/MYSQL-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>在 MySQL 中，使用 SELECT 语句进行基本的查询操作。</p>
<h2 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h2><p>查看表的基本属性</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> users;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">DESC</span> users;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">desc</span> users;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field          <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> employee_id    <span class="operator">|</span> <span class="type">int</span>(<span class="number">6</span>)      <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="number">0</span>       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> first_name     <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">20</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> last_name      <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">25</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> email          <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">25</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> UNI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> phone_number   <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">20</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> hire_date      <span class="operator">|</span> <span class="type">date</span>        <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> job_id         <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">10</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> MUL <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> salary         <span class="operator">|</span> <span class="keyword">double</span>(<span class="number">8</span>,<span class="number">2</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> commission_pct <span class="operator">|</span> <span class="keyword">double</span>(<span class="number">2</span>,<span class="number">2</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> manager_id     <span class="operator">|</span> <span class="type">int</span>(<span class="number">6</span>)      <span class="operator">|</span> YES  <span class="operator">|</span> MUL <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> department_id  <span class="operator">|</span> <span class="type">int</span>(<span class="number">4</span>)      <span class="operator">|</span> YES  <span class="operator">|</span> MUL <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></div>

<h2 id="基本的SELECT语法"><a href="#基本的SELECT语法" class="headerlink" title="基本的SELECT语法"></a>基本的SELECT语法</h2><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><strong><code>SELECT</code></strong> 关键字用于指定要检索的列。</li>
<li><strong><code>column1, column2, ...</code></strong> 是要选择的列名，用逗号分隔。</li>
<li><strong><code>FROM table_name</code></strong> 表示从哪个表中检索数据。</li>
</ol>
<h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a><strong>常见操作</strong></h2><h3 id="查询所有列"><a href="#查询所有列" class="headerlink" title="查询所有列"></a><strong>查询所有列</strong></h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users;</span><br></pre></td></tr></table></figure></div>

<p>这将检索 <strong><code>users</code></strong> 表中的所有列的数据。</p>
<h3 id="选择特定列的数据"><a href="#选择特定列的数据" class="headerlink" title="选择特定列的数据"></a><strong>选择特定列的数据</strong></h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name, last_name <span class="keyword">FROM</span> users;</span><br></pre></td></tr></table></figure></div>

<p>这将只检索 <strong><code>users</code></strong> 表中 <strong><code>first_name</code></strong> 和 <strong><code>last_name</code></strong> 列的数据。</p>
<h3 id="去除重复行"><a href="#去除重复行" class="headerlink" title="去除重复行"></a>去除重复行</h3><p>查询的数据中，有多行数据相同，则可以通过DISTINCT来去重。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name</span><br><span class="line"><span class="keyword">FROM</span> users;</span><br></pre></td></tr></table></figure></div>

<p>这将检索<code>**users**</code>表中相同<code>**name**</code>的行去重，只保留一行。</p>
<h3 id="添加一列常量数据"><a href="#添加一列常量数据" class="headerlink" title="添加一列常量数据"></a>添加一列常量数据</h3><p>可以使用<code>**[字符串/数字] as 列名**</code>，添加一列常量数据，与查询的数据进行合并。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, <span class="string">&#x27;constant_value&#x27;</span> <span class="keyword">AS</span> new_column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><strong><code>AS new_column_name</code></strong> 用于为新添加的常量列指定列名。</li>
</ol>
<h2 id="添加条件WHERE子句"><a href="#添加条件WHERE子句" class="headerlink" title="添加条件WHERE子句"></a><strong><strong>添加条件WHERE子句</strong></strong></h2><p>要筛选特定的行，可以使用 <strong><code>WHERE</code></strong> 子句添加条件。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>例子</strong></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">25</span>;</span><br></pre></td></tr></table></figure></div>

<p>查询user表中选择所有age大于25的用户数据。</p>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL-基础知识</title>
    <url>/2023/11/09/Mysql/Basic/MYSQL-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>整数类型</td>
<td></td>
</tr>
<tr>
<td>TINYINT</td>
<td>很小的整数值。有符号范围是 -128 到 127，无符号范围是 0 到 255。</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>小整数值。有符号范围是 -32,768 到 32,767，无符号范围是 0 到 65,535。</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>中等大小整数值。有符号范围是 -8,388,608 到 8,388,607，无符号范围是 0 到 16,777,215。</td>
</tr>
<tr>
<td>INT&#x2F;INTEGER</td>
<td>普通大小整数值。有符号范围是 -2,147,483,648 到 2,147,483,647，无符号范围是 0 到 4,294,967,295。</td>
</tr>
<tr>
<td>BIGINT</td>
<td>大整数值。有符号范围是 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807，无符号范围是 0 到 18,446,744,073,709,551,615。</td>
</tr>
<tr>
<td>浮点类型</td>
<td></td>
</tr>
<tr>
<td>FLOAT</td>
<td>单精度浮点数。范围约为 -3.4E+38 到 3.4E+38。</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>双精度浮点数。范围约为 -1.7E+308 到 1.7E+308。</td>
</tr>
<tr>
<td>DECIMAL</td>
<td>固定小数点数。允许小数点数值的存储。</td>
</tr>
<tr>
<td>日期&#x2F;时间类型</td>
<td></td>
</tr>
<tr>
<td>DATE</td>
<td>日期值。格式为 ‘YYYY-MM-DD’。</td>
</tr>
<tr>
<td>TIME</td>
<td>时间值。格式为 ‘HH:MM:SS’。</td>
</tr>
<tr>
<td>DATETIME</td>
<td>混合日期和时间值。格式为 ‘YYYY-MM-DD HH:MM:SS’。</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>时间戳。使用 YYYYMMDDHHMMSS 格式（如 ‘20231106123000’）存储日期和时间。</td>
</tr>
<tr>
<td>YEAR</td>
<td>年份值。格式为 ‘YYYY’。</td>
</tr>
<tr>
<td>字符串类型</td>
<td></td>
</tr>
<tr>
<td>CHAR</td>
<td>固定长度字符串，最多 255 个字符。</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>可变长度字符串，最多 65,535 字符。</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>极小文本字段，最多 255 字符。</td>
</tr>
<tr>
<td>TEXT</td>
<td>小型文本字段，最多 65,535 字符。</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>中等大小文本字段，最多 16,777,215 字符。</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>长文本字段，最多 4,294,967,295 字符。</td>
</tr>
<tr>
<td>二进制类型</td>
<td></td>
</tr>
<tr>
<td>BINARY</td>
<td>固定长度二进制字符串。</td>
</tr>
<tr>
<td>VARBINARY</td>
<td>可变长度二进制字符串。</td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>极小二进制对象，最多 255 字节。</td>
</tr>
<tr>
<td>BLOB</td>
<td>小型二进制对象，最多 65,535 字节。</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>中等大小二进制对象，最多 16,777,215 字节。</td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>长二进制对象，最多 4,294,967,295 字节。</td>
</tr>
</tbody></table>
<h2 id="SQL语言的规则与规范"><a href="#SQL语言的规则与规范" class="headerlink" title="SQL语言的规则与规范"></a>SQL语言的规则与规范</h2><h3 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h3><ol>
<li>SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进</li>
<li>关键字不能被缩写也不能分行</li>
<li>关于标点符号<ol>
<li>必须保证所有的()、单引号、双引号是成对结束的</li>
<li>必须使用英文状态下的半角输入方式</li>
<li>字符串型和日期时间类型的数据可以使用<strong>单引号</strong>表示</li>
<li>列的别名，尽量使用<strong>双引号</strong>，而且不建议省略as</li>
</ol>
</li>
</ol>
<h3 id="SQL大小写规范-（建议遵守）"><a href="#SQL大小写规范-（建议遵守）" class="headerlink" title="SQL大小写规范 （建议遵守）"></a>SQL大小写规范 （建议遵守）</h3><ul>
<li><strong>MySQL 在 Windows 环境下是大小写不敏感的</strong></li>
<li><strong>MySQL 在 Linux 环境下是大小写敏感的</strong><ul>
<li>数据库名、表名、表的别名、变量名是严格区分大小写的</li>
<li>关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。</li>
</ul>
</li>
<li><strong>推荐采用统一的书写规范：</strong><ul>
<li>数据库名、表名、表别名、字段名、字段别名等都小写</li>
<li>SQL 关键字、函数名、绑定变量等都大写</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL-增删改</title>
    <url>/2023/11/10/Mysql/Basic/MYSQL-%E5%A2%9E%E5%88%A0%E6%94%B9/</url>
    <content><![CDATA[<p>MySQL是一个流行的关系型数据库管理系统，支持四种主要类型的操作：</p>
<p><strong>增加（INSERT）、删除（DELETE）、修改（UPDATE）、以及查询（SELECT）</strong>，通常简称为CRUD操作。以下是这些操作的简要说明：</p>
<ol>
<li><p><strong>增加数据（INSERT）</strong></p>
<p> <code>**INSERT**</code>命令用于将新的行插入到数据库表中。语法如下：</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2, column3, ...)</span><br><span class="line"><span class="keyword">VALUES</span> (value1, value2, value3, ...);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>删除数据（DELETE）</strong></p>
<p> **<code>DELETE</code>**命令用于从数据库表中删除行。语法如下：</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>修改数据（UPDATE）</strong></p>
<p> **<code>UPDATE</code>**命令用于更新数据库表中的现有行。语法如下：</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> value1, column2 <span class="operator">=</span> value2, ...</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>这些CRUD操作构成了对MySQL数据库进行常见操作的基础。通过这些操作，可以添加新数据、修改现有数据、删除数据或从数据库中检索数据。</p>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL-多表查询</title>
    <url>/2023/11/11/Mysql/Basic/MYSQL-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>多表查询根据连接方式可以分类：<strong>内连接、外连接、交叉链接、自连接</strong>。</p>
<p>多表查询是用于从多个表中联合提取数据的技术。在 SQL 中，多表查询通常涉及使用 <strong><code>JOIN</code></strong> 子句来连接不同的表。</p>
<p><strong>基本语法：</strong></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 </span><br><span class="line">[<span class="keyword">INNER</span><span class="operator">|</span><span class="keyword">LEFT</span><span class="operator">|</span><span class="keyword">RIGHT</span><span class="operator">|</span><span class="keyword">FULL</span><span class="operator">|</span><span class="keyword">CROSS</span>] <span class="keyword">JOIN</span> table2 </span><br><span class="line"><span class="keyword">ON</span> [过滤条件]</span><br></pre></td></tr></table></figure></div>

<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>内连接，又叫等值连接，顾名思义只有两张表中匹配的数据才会发生连接，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://prod-files-secure.s3.us-west-2.amazonaws.com/d0cb0889-16a1-478b-89f7-56969f412d28/629064ab-b54a-4f3e-88c3-c662b06c0e72/Untitled.png"
                      alt="Untitled"
                ></p>
<p><strong>基本语法：</strong></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.column_name <span class="operator">=</span> table2.column_name;</span><br></pre></td></tr></table></figure></div>

<p><strong>过程解析：</strong></p>
<ol>
<li>遍历左表数据，用左表数据的联属性去匹配右表的每一条数据。</li>
<li>如果关联属性相同，则匹配到一条数据。</li>
</ol>
<p><strong>示例：</strong></p>
<p>假设有两个表 <strong><code>orders</code></strong> 和 **<code>customers</code>**，我们将执行一个内连接以查看订单信息及其关联的顾客信息。</p>
<p>customers 表：</p>
<table>
<thead>
<tr>
<th>customer_id</th>
<th>customer_name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>John</td>
</tr>
<tr>
<td>2</td>
<td>Alice</td>
</tr>
<tr>
<td>3</td>
<td>Bob</td>
</tr>
</tbody></table>
<p>orders 表：</p>
<table>
<thead>
<tr>
<th>order_id</th>
<th>order_date</th>
<th>customer_id</th>
<th>total</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2023-01-15</td>
<td>2</td>
<td>150</td>
</tr>
<tr>
<td>2</td>
<td>2023-01-18</td>
<td>1</td>
<td>200</td>
</tr>
<tr>
<td>3</td>
<td>2023-01-20</td>
<td>4</td>
<td>100</td>
</tr>
</tbody></table>
<p>以下是一个内连接的 SQL 查询，它将显示所有订单信息，并且显示与之相关联的顾客信息（如果有匹配的顾客信息）：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> customers <span class="keyword">ON</span> orders.customer_id <span class="operator">=</span> customers.customer_id;</span><br></pre></td></tr></table></figure></div>

<p>结果将显示所有订单信息以及与之匹配的顾客信息。对于那些没有匹配的订单（比如 order_id 为 3 的订单，customer_id 为 4，在 customers 表中找不到匹配的 customer_id），将不会显示在结果中。</p>
<table>
<thead>
<tr>
<th>order_id</th>
<th>order_date</th>
<th>customer_id</th>
<th>total</th>
<th>customer_id</th>
<th>customer_name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2023-01-15</td>
<td>2</td>
<td>150</td>
<td>2</td>
<td>Alice</td>
</tr>
<tr>
<td>2</td>
<td>2023-01-18</td>
<td>1</td>
<td>200</td>
<td>1</td>
<td>John</td>
</tr>
</tbody></table>
<hr>
<h3 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://prod-files-secure.s3.us-west-2.amazonaws.com/d0cb0889-16a1-478b-89f7-56969f412d28/6c0daa57-8c8f-44bd-9e0a-1a3d9e6196f6/Untitled.png"
                      alt="Untitled"
                ></p>
<p><strong>基本语法：</strong></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.column_name <span class="operator">=</span> table2.column_name;</span><br></pre></td></tr></table></figure></div>

<p><strong>过程解析：</strong></p>
<ol>
<li>遍历table1数据，用table1数据的关联属性去匹配table2中的每一条数据。</li>
<li>如果关联属性相同，则匹配到一条数据；</li>
<li>如果table1数据没有匹配到table2的任何一条数据，则将右表数据的所有字段置为NULL，仍记作匹配到一条数据。</li>
</ol>
<p><strong>示例：</strong></p>
<p>假设有两个表 <strong><code>departments</code></strong> 和 **<code>employees</code>**，我们将执行一个左连接操作以查看部门信息以及与之相关联的员工信息。</p>
<p>departments 表：</p>
<table>
<thead>
<tr>
<th>dept_id</th>
<th>dept_name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Sales</td>
</tr>
<tr>
<td>2</td>
<td>IT</td>
</tr>
<tr>
<td>3</td>
<td>HR</td>
</tr>
</tbody></table>
<p>employees 表：</p>
<table>
<thead>
<tr>
<th>emp_id</th>
<th>emp_name</th>
<th>emp_department_id</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>John</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>Alice</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>Bob</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>Emily</td>
<td>4</td>
</tr>
</tbody></table>
<p>以下是一个左连接的 SQL 查询，它将显示所有部门信息，并且与之相关联的员工信息（如果有）：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> departments</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees <span class="keyword">ON</span> departments.dept_id <span class="operator">=</span> employees.emp_department_id;</span><br></pre></td></tr></table></figure></div>

<p>结果将显示所有部门信息以及与之匹配的员工信息，如果员工信息不存在，对应列将会显示 NULL：</p>
<table>
<thead>
<tr>
<th>dept_id</th>
<th>dept_name</th>
<th>emp_id</th>
<th>emp_name</th>
<th>emp_department_id</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Sales</td>
<td>2</td>
<td>Alice</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>IT</td>
<td>1</td>
<td>John</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>IT</td>
<td>3</td>
<td>Bob</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>HR</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
</tr>
</tbody></table>
<hr>
<h3 id="右连接"><a href="#右连接" class="headerlink" title="右连接"></a>右连接</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://prod-files-secure.s3.us-west-2.amazonaws.com/d0cb0889-16a1-478b-89f7-56969f412d28/cd8f31b9-99d7-4665-a68b-a96e1996e974/Untitled.png"
                      alt="Untitled"
                ></p>
<p><strong>基本语法：</strong></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.column_name <span class="operator">=</span> table2.column_name;</span><br></pre></td></tr></table></figure></div>

<p><strong>过程解析：</strong></p>
<ol>
<li>遍历table2数据，用table1数据的关联属性去匹配table1中的每一条数据。</li>
<li>如果关联属性相同，则匹配到一条数据；</li>
<li>如果table2数据没有匹配到table1的任何一条数据，则将右表数据的所有字段置为NULL，仍记作匹配到一条数据。</li>
</ol>
<p><strong>示例：</strong></p>
<p>假设有两个表 <strong><code>students</code></strong> 和 <strong><code>grades</code></strong> ，我们尝试执行右连接以查看学生及其对应的成绩，即显示所有成绩表中的数据，以及与之匹配的学生信息。</p>
<p>students 表：</p>
<table>
<thead>
<tr>
<th>student_id</th>
<th>student_name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Alice</td>
</tr>
<tr>
<td>2</td>
<td>Bob</td>
</tr>
<tr>
<td>3</td>
<td>John</td>
</tr>
</tbody></table>
<p>grades 表：</p>
<table>
<thead>
<tr>
<th>student_id</th>
<th>grade</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>A</td>
</tr>
<tr>
<td>3</td>
<td>B</td>
</tr>
<tr>
<td>4</td>
<td>C</td>
</tr>
</tbody></table>
<p>执行右连接</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> grades <span class="keyword">ON</span> students.student_id <span class="operator">=</span> grades.student_id;</span><br></pre></td></tr></table></figure></div>

<p>结果会显示 grades 表中的所有数据，并且匹配的学生信息（student_id 存在于 students 表中）：</p>
<table>
<thead>
<tr>
<th>student_id</th>
<th>student_name</th>
<th>student_id</th>
<th>grade</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Alice</td>
<td>1</td>
<td>A</td>
</tr>
<tr>
<td>3</td>
<td>John</td>
<td>3</td>
<td>B</td>
</tr>
<tr>
<td>NULL</td>
<td>NULL</td>
<td>4</td>
<td>C</td>
</tr>
</tbody></table>
<hr>
<h3 id="全外连接"><a href="#全外连接" class="headerlink" title="全外连接"></a>全外连接</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://prod-files-secure.s3.us-west-2.amazonaws.com/d0cb0889-16a1-478b-89f7-56969f412d28/6a03d5bf-a310-46cc-8169-9b116c26942c/Untitled.png"
                      alt="Untitled"
                ></p>
<p>在 MySQL 中，实际上并没有直接支持全连接（FULL JOIN）的语法。而是可以通过模拟来完成全连接的操作，常见的方法是使用**<code>UNION</code>** 和 LEFT JOIN 与 RIGHT JOIN 结合。</p>
<p><strong>基本语法：</strong></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.column_name <span class="operator">=</span> table2.column_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.column_name <span class="operator">=</span> table2.column_name;</span><br></pre></td></tr></table></figure></div>

<p><strong>过程解析：</strong></p>
<ol>
<li>先对左右表做左连接，再对左右表做右连接</li>
<li>使用 UNION 运算符将两个结果集合并起来，去重，这样就得到了类似于全连接的结果，包含了两个表中的所有行。</li>
<li>如果不想去重，则使用**<code>UNION ALL</code>**运算符。</li>
</ol>
<p><strong><strong>示例：</strong></strong></p>
<p>employees 表：</p>
<table>
<thead>
<tr>
<th>emp_id</th>
<th>emp_name</th>
<th>emp_department_id</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>John</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>Alice</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>Bob</td>
<td>2</td>
</tr>
</tbody></table>
<p>departments 表：</p>
<table>
<thead>
<tr>
<th>dept_id</th>
<th>dept_name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Sales</td>
</tr>
<tr>
<td>2</td>
<td>IT</td>
</tr>
<tr>
<td>4</td>
<td>Marketing</td>
</tr>
</tbody></table>
<p>执行全外连接：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments <span class="keyword">ON</span> employees.emp_department_id <span class="operator">=</span> departments.dept_id</span><br><span class="line"></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments <span class="keyword">ON</span> employees.emp_department_id <span class="operator">=</span> departments.dept_id;</span><br></pre></td></tr></table></figure></div>

<p>结果将包含了两个表中的不匹配的行和匹配的行。假设要观察员工和部门信息的匹配与不匹配情况：</p>
<table>
<thead>
<tr>
<th>emp_id</th>
<th>emp_name</th>
<th>emp_department_id</th>
<th>dept_id</th>
<th>dept_name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>John</td>
<td>2</td>
<td>2</td>
<td>IT</td>
</tr>
<tr>
<td>2</td>
<td>Alice</td>
<td>1</td>
<td>1</td>
<td>Sales</td>
</tr>
<tr>
<td>3</td>
<td>Bob</td>
<td>2</td>
<td>2</td>
<td>IT</td>
</tr>
<tr>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>4</td>
<td>Marketing</td>
</tr>
</tbody></table>
<hr>
<h3 id="交叉连接（笛卡儿积）"><a href="#交叉连接（笛卡儿积）" class="headerlink" title="交叉连接（笛卡儿积）"></a>交叉连接（笛卡儿积）</h3><p>在 MySQL 中，交叉连接（CROSS JOIN）是一种连接类型，它返回两个表的笛卡尔积，也就是第一个表的每一行与第二个表的每一行进行组合。在没有指定任何条件的情况下，交叉连接会返回两个表中的所有可能组合。</p>
<p><strong>基本语法：</strong></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> table2;</span><br></pre></td></tr></table></figure></div>

<p>这个语句将返回 <strong><code>table1</code></strong> 和 <strong><code>table2</code></strong> 中所有行的组合。如果 <strong><code>table1</code></strong> 有 5 行，而 <strong><code>table2</code></strong> 有 3 行，则交叉连接将返回 5 × 3 &#x3D; 15 行。</p>
<p><strong><strong>示例：</strong></strong></p>
<p>假设有两个简单的表：</p>
<p>Table1:</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>John</td>
</tr>
<tr>
<td>2</td>
<td>Alice</td>
</tr>
<tr>
<td>3</td>
<td>Bob</td>
</tr>
</tbody></table>
<p>Table2:</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Product</th>
</tr>
</thead>
<tbody><tr>
<td>101</td>
<td>Apple</td>
</tr>
<tr>
<td>102</td>
<td>Orange</td>
</tr>
<tr>
<td>103</td>
<td>Banana</td>
</tr>
</tbody></table>
<p>执行交叉连接：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Table1</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> Table2;</span><br></pre></td></tr></table></figure></div>

<p>这将返回 <strong><code>Table1</code></strong> 和 <strong><code>Table2</code></strong> 的笛卡尔积，得到的结果将包含 3 × 3 &#x3D; 9 行：</p>
<table>
<thead>
<tr>
<th>Table1.ID</th>
<th>Table1.Name</th>
<th>Table2.ID</th>
<th>Table2.Product</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>John</td>
<td>101</td>
<td>Apple</td>
</tr>
<tr>
<td>1</td>
<td>John</td>
<td>102</td>
<td>Orange</td>
</tr>
<tr>
<td>1</td>
<td>John</td>
<td>103</td>
<td>Banana</td>
</tr>
<tr>
<td>2</td>
<td>Alice</td>
<td>101</td>
<td>Apple</td>
</tr>
<tr>
<td>2</td>
<td>Alice</td>
<td>102</td>
<td>Orange</td>
</tr>
<tr>
<td>2</td>
<td>Alice</td>
<td>103</td>
<td>Banana</td>
</tr>
<tr>
<td>3</td>
<td>Bob</td>
<td>101</td>
<td>Apple</td>
</tr>
<tr>
<td>3</td>
<td>Bob</td>
<td>102</td>
<td>Orange</td>
</tr>
<tr>
<td>3</td>
<td>Bob</td>
<td>103</td>
<td>Banana</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL-排序</title>
    <url>/2023/11/11/Mysql/Basic/MYSQL-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>在 MySQL 中，可以使用 <strong><code>ORDER BY</code></strong> 子句对检索到的数据进行排序。**<code>ORDER BY</code>** 用于根据一个或多个列对结果进行升序或降序排列。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column1 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], column2 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], ...;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><strong><code>ORDER BY</code></strong> 后面跟着想要排序的列名，可以是一个或多个列。</li>
<li><strong><code>[ASC|DESC]</code></strong> 用于指定排序方式，默认是升序 (<strong><code>ASC</code></strong>)。</li>
</ol>
<h2 id="在特定条件下排序"><a href="#在特定条件下排序" class="headerlink" title="在特定条件下排序"></a><strong><strong>在特定条件下排序</strong></strong></h2><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> country <span class="operator">=</span> <span class="string">&#x27;USA&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> last_name <span class="keyword">ASC</span>, first_name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure></div>

<p>这将从居住在美国的顾客中，</p>
<ol>
<li>先对姓氏升序；</li>
<li>再对于相同姓氏的顾客，按名字升序排列。</li>
</ol>
<h2 id="对-NULL-值排序"><a href="#对-NULL-值排序" class="headerlink" title="对 NULL 值排序"></a><strong><strong>对 NULL 值排序</strong></strong></h2><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> last_login_date <span class="keyword">DESC</span> NULLS <span class="keyword">LAST</span>;</span><br></pre></td></tr></table></figure></div>

<p>这将按照最后登录日期降序排序，将所有的 NULL 值放在排序结果的最后。</p>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL-常见函数</title>
    <url>/2023/11/11/Mysql/Basic/MYSQL-%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="MySQL的内置函数及分类"><a href="#MySQL的内置函数及分类" class="headerlink" title="MySQL的内置函数及分类"></a>MySQL的内置函数及分类</h2><p>MySQL提供了丰富的内置函数，这些函数使得数据的维护与管理更加方便，能够更好地提供数据的分析与统计功能，在一定程度上提高了开发人员进行数据分析与统计的效率。</p>
<p>MySQL提供的内置函数从<strong>实现的功能角度</strong>可以分为<strong>数值函数</strong>、<strong>字符串函数</strong>、<strong>日期和时间函数</strong>、<strong>流程控制函数</strong>、<strong>加密与解密函数</strong>、<strong>获取MySQL信息函数</strong>、<strong>聚合函数</strong>等。</p>
<p>这里，我将这些丰富的内置函数再分为两类：<strong>单行函数</strong>、<strong>聚合函数</strong>（或分组函数）。</p>
<h2 id="数值型函数"><a href="#数值型函数" class="headerlink" title="数值型函数"></a>数值型函数</h2><table>
<thead>
<tr>
<th>函数名称</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/abc.html%EF%BC%88-4%EF%BC%89=4" >https://c.biancheng.net/mysql/abc.html（-4）=4 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>求绝对值</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/sqrt.html%EF%BC%8825%EF%BC%89=5" >https://c.biancheng.net/mysql/sqrt.html（25）=5 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>求二次方根</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/mod.html%EF%BC%88120,10%EF%BC%89=0" >https://c.biancheng.net/mysql/mod.html（120,10）=0 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>求余数</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/ceil_celing.html" >https://c.biancheng.net/mysql/ceil_celing.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>两个函数功能相同，都是返回不小于参数的最小整数，即向上取整</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/floor.html" >https://c.biancheng.net/mysql/floor.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>向下取整，返回值转化为一个BIGINT</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/rand.html" >https://c.biancheng.net/mysql/rand.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/round.html" >https://c.biancheng.net/mysql/round.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>对所传参数进行四舍五入</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/sign.html" >https://c.biancheng.net/mysql/sign.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>返回参数的符号</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/pow_power.html" >https://c.biancheng.net/mysql/pow_power.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>两个函数的功能相同，都是所传参数的次方的结果值</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/sin.html" >https://c.biancheng.net/mysql/sin.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>求正弦值</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/asin.html" >https://c.biancheng.net/mysql/asin.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>求反正弦值，与函数 SIN 互为反函数</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/cos.html" >https://c.biancheng.net/mysql/cos.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>求余弦值</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/acos.html" >https://c.biancheng.net/mysql/acos.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>求反余弦值，与函数 COS 互为反函数</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/tan.html" >https://c.biancheng.net/mysql/tan.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>求正切值</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/atan.html" >https://c.biancheng.net/mysql/atan.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>求反正切值，与函数 TAN 互为反函数</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/cot.html" >https://c.biancheng.net/mysql/cot.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>求余切值</td>
</tr>
</tbody></table>
<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><table>
<thead>
<tr>
<th>函数名称</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/length.html" >https://c.biancheng.net/mysql/length.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>计算字符串长度函数，返回字符串的字节长度</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/concat.html" >https://c.biancheng.net/mysql/concat.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/insert.html" >https://c.biancheng.net/mysql/insert.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>替换字符串函数</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/lower.html" >https://c.biancheng.net/mysql/lower.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>将字符串中的字母转换为小写</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/upper.html" >https://c.biancheng.net/mysql/upper.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>将字符串中的字母转换为大写</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/left.html" >https://c.biancheng.net/mysql/left.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>从左侧字截取符串，返回字符串左边的若干个字符</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/right.html" >https://c.biancheng.net/mysql/right.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>从右侧字截取符串，返回字符串右边的若干个字符</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/trim.html" >https://c.biancheng.net/mysql/trim.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>删除字符串左右两侧的空格</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/replace.html" >https://c.biancheng.net/mysql/replace.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>字符串替换函数，返回替换后的新字符串</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/substring.html" >https://c.biancheng.net/mysql/substring.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>截取字符串，返回从指定位置开始的指定长度的字符换</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/reverse.html" >https://c.biancheng.net/mysql/reverse.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串</td>
</tr>
</tbody></table>
<h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><table>
<thead>
<tr>
<th>函数名称</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/curdate_current_date.html" >https://c.biancheng.net/mysql/curdate_current_date.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>两个函数作用相同，返回当前系统的日期值</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/curtime_current_time.html" >https://c.biancheng.net/mysql/curtime_current_time.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>两个函数作用相同，返回当前系统的时间值</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/now_sysdate.html" >https://c.biancheng.net/mysql/now_sysdate.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>两个函数作用相同，返回当前系统的日期和时间值</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/unix_timestamp.html" >https://c.biancheng.net/mysql/unix_timestamp.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>获取UNIX时间戳函数，返回一个以 UNIX 时间戳为基础的无符号整数</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/from_unixtime.html" >https://c.biancheng.net/mysql/from_unixtime.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>将 UNIX 时间戳转换为时间格式，与UNIX_TIMESTAMP互为反函数</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/month.html" >https://c.biancheng.net/mysql/month.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>获取指定日期中的月份</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/monthname.html" >https://c.biancheng.net/mysql/monthname.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>获取指定日期中的月份英文名称</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/dayname.html" >https://c.biancheng.net/mysql/dayname.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>获取指定曰期对应的星期几的英文名称</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/dayofweek.html" >https://c.biancheng.net/mysql/dayofweek.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>获取指定日期对应的一周的索引位置值</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/week.html" >https://c.biancheng.net/mysql/week.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/dayofyear.html" >https://c.biancheng.net/mysql/dayofyear.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>获取指定曰期是一年中的第几天，返回值范围是1~366</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/dayofmonth.html" >https://c.biancheng.net/mysql/dayofmonth.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>获取指定日期是一个月中是第几天，返回值范围是1~31</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/year.html" >https://c.biancheng.net/mysql/year.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>获取年份，返回值范围是 1970〜2069</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/time_to_sec.html" >https://c.biancheng.net/mysql/time_to_sec.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>将时间参数转换为秒数</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/sec_to_time.html" >https://c.biancheng.net/mysql/sec_to_time.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>将秒数转换为时间，与TIME_TO_SEC 互为反函数</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/date_add_adddate.html" >https://c.biancheng.net/mysql/date_add_adddate.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>两个函数功能相同，都是向日期添加指定的时间间隔</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/date_sub_subdate.html" >https://c.biancheng.net/mysql/date_sub_subdate.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>两个函数功能相同，都是向日期减去指定的时间间隔</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/addtime.html" >https://c.biancheng.net/mysql/addtime.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>时间加法运算，在原始时间上添加指定的时间</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/subtime.html" >https://c.biancheng.net/mysql/subtime.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>时间减法运算，在原始时间上减去指定的时间</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/datediff.html" >https://c.biancheng.net/mysql/datediff.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>获取两个日期之间间隔，返回参数 1 减去参数 2 的值</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/date_format.html" >https://c.biancheng.net/mysql/date_format.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>格式化指定的日期，根据参数返回指定格式的值</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/weekday.html" >https://c.biancheng.net/mysql/weekday.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>获取指定日期在一周内的对应的工作日索引</td>
</tr>
</tbody></table>
<h2 id="控制流函数"><a href="#控制流函数" class="headerlink" title="控制流函数"></a>控制流函数</h2><table>
<thead>
<tr>
<th>函数名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/if.html" >https://c.biancheng.net/mysql/if.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>判断，流程控制</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/ifnull.html" >https://c.biancheng.net/mysql/ifnull.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>判断是否为空</td>
</tr>
<tr>
<td><a class="link"   href="https://c.biancheng.net/mysql/case.html" >https://c.biancheng.net/mysql/case.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
<td>搜索语句</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<ol>
<li><p><strong>CASE</strong>：</p>
<p> **<code>CASE</code><strong>函数类似于编程语言中的</strong><code>switch</code>**语句，根据条件选择不同的结果。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">CASE</span> </span><br><span class="line">        <span class="keyword">WHEN</span> condition1 <span class="keyword">THEN</span> result1</span><br><span class="line">        <span class="keyword">WHEN</span> condition2 <span class="keyword">THEN</span> result2</span><br><span class="line">        <span class="keyword">ELSE</span> result_default</span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line"><span class="keyword">FROM</span> your_table;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>IF()</strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> IF(<span class="keyword">condition</span>, value_if_true, value_if_false) <span class="keyword">FROM</span> your_table;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>MD5(string)</td>
<td>返回字符串的 MD5 散列（不建议使用）</td>
</tr>
<tr>
<td>SHA1(string)</td>
<td>返回字符串的 SHA1 散列（不建议使用）</td>
</tr>
<tr>
<td>SHA2(string, length)</td>
<td>返回字符串的SHA2散列，length参数表示摘要长度</td>
</tr>
<tr>
<td>AES_ENCRYPT(data, key_str)</td>
<td>使用密钥加密数据</td>
</tr>
<tr>
<td>AES_DECRYPT(data, key_str)</td>
<td>使用密钥解密已加密的数据</td>
</tr>
</tbody></table>
<p>请注意，MD5、SHA1这类散列算法不再被推荐用于加密敏感数据，因为它们容易受到碰撞攻击。</p>
<p>而SHA2和AES_ENCRYPT&#x2F;AES_DECRYPT可以提供更强大的安全性。在实际使用中，请格外小心保护密钥，以确保数据的安全性。</p>
<p><strong>示例：</strong></p>
<ol>
<li><p><strong>SHA2()</strong>:</p>
<p> **<code>SHA2()</code>**函数可以计算字符串的 SHA2 散列值，提供更好的安全性。可以指定不同的摘要长度（SHA-256、SHA-512等）。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SHA2(<span class="string">&#x27;your_password&#x27;</span>, <span class="number">256</span>); <span class="comment">-- 这里的256代表摘要长度</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>AES_ENCRYPT() &#x2F; AES_DECRYPT()</strong>:</p>
<p> <strong><code>AES_ENCRYPT()</code></strong> 和 <strong><code>AES_DECRYPT()</code></strong> 是用于加密和解密数据的函数，使用相同的密钥进行加密和解密。这些函数可以用于加密数据，并且支持更强大的加密算法。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> AES_ENCRYPT(<span class="string">&#x27;your_password&#x27;</span>, <span class="string">&#x27;encryption_key&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> AES_DECRYPT(encrypted_column, <span class="string">&#x27;encryption_key&#x27;</span>);</span><br></pre></td></tr></table></figure></div></li>
</ol>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL-数据库管理</title>
    <url>/2023/11/09/Mysql/Basic/MYSQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="管理数据库"><a href="#管理数据库" class="headerlink" title="管理数据库"></a>管理数据库</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><ol>
<li><p><strong>使用的是默认字符集</strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE mytest1;  </span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>指定字符集</strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE mytest2 <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="string">&#x27;gbk&#x27;</span>;  #指定数据库的字符集为&quot;gbk&quot;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>判断数据库是否已经存在，不存在则创建数据库（<strong>推荐</strong>）</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 数据库名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> mytest2 <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="string">&#x27;gbk&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="管理数据库-1"><a href="#管理数据库-1" class="headerlink" title="管理数据库"></a>管理数据库</h3><ol>
<li><p><strong>使用&#x2F;切换数据库</strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>查看当前所有的数据库</strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;          #有一个S，代表多个数据库</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>查看当前正在使用的数据库</strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE();  #使用的一个 mysql 中的全局函数</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>查看指定库下所有的表</strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES <span class="keyword">FROM</span> 数据库名;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>查看数据库的创建的语句结构</strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表明;        #查看创建表的语句结构</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="修改数据库（ALTER）"><a href="#修改数据库（ALTER）" class="headerlink" title="修改数据库（ALTER）"></a>修改数据库（ALTER）</h3><ol>
<li><p><strong>更改数据库字符集</strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE 数据库名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集;  #比如：gbk、utf8等</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> DATABASE mytest2 <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="string">&#x27;utf8&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="删除数据库（DROP）"><a href="#删除数据库（DROP）" class="headerlink" title="删除数据库（DROP）"></a>删除数据库（DROP）</h3><ol>
<li><p><strong>删除指定的数据库</strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE 数据库名;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>删除指定的数据库（推荐）</strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> 数据库名;</span><br></pre></td></tr></table></figure></div></li>
</ol>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Basical-knowledge</title>
    <url>/2023/11/07/Java/Basic/Java-Basical-knowledge/</url>
    <content><![CDATA[<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><table>
<thead>
<tr>
<th>访问修饰符</th>
<th>类内部</th>
<th>同一包内</th>
<th>子类</th>
<th>其他包</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>✔️</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>default</td>
<td>✔️</td>
<td>✔️</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>protected</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>❌</td>
</tr>
<tr>
<td>public</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
</tr>
</tbody></table>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Java中有八大基本数据类型，它们可以分为两类：数值类型和字符类型。</p>
<p><strong>数值类型：</strong></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>大小</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte（字节）</td>
<td>8位</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>short（短整数）</td>
<td>16位</td>
<td>-32,768 ~ 32,767</td>
</tr>
<tr>
<td>int（整数）</td>
<td>32位</td>
<td>2^31 ~ 2^31 - 1。</td>
</tr>
<tr>
<td>long（长整数）</td>
<td>64位</td>
<td>2^63 ~ 2^63 - 1。</td>
</tr>
<tr>
<td>float（单精度浮点数）</td>
<td>32位</td>
<td>浮点数类型（小数），如2.0f</td>
</tr>
<tr>
<td>double（双精度整数）</td>
<td>64位</td>
<td>更高精度的浮点数类型，如2.0</td>
</tr>
</tbody></table>
<p><strong>字符类型：</strong></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>大小</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>char（字符）</td>
<td>16位</td>
<td>用于表示Unicode字符，1字符&#x3D;2个字节</td>
</tr>
</tbody></table>
<p><strong>布尔类型：</strong></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>大小</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>boolean（布尔）</td>
<td>表示逻辑值</td>
<td>true  &amp;  false</td>
</tr>
</tbody></table>
<h2 id="为什么浮点运算的时候会有精度丢失的风险？"><a href="#为什么浮点运算的时候会有精度丢失的风险？" class="headerlink" title="为什么浮点运算的时候会有精度丢失的风险？"></a>为什么浮点运算的时候会有精度丢失的风险？</h2><p>浮点数运算精度丢失代码演示：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2.0f</span> - <span class="number">1.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1.8f</span> - <span class="number">1.7f</span>;</span><br><span class="line">System.out.println(a);       <span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);       <span class="comment">// 0.099999905</span></span><br><span class="line">System.out.println(a == b);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>

<p>为什么会出现这个问题呢？</p>
<p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p>
<p><strong>解决办法：</strong></p>
<ol>
<li><p><strong>BigDecimal</strong>：使用BigDecimal类来进行高精度的十进制数值运算，可以精确表示和计算小数，而不会出现读点书的精度问题。</p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;2.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.1&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">result</span> <span class="operator">=</span> num1.subtract(num2);   <span class="comment">//减法</span></span><br><span class="line">System.out.println(result);                <span class="comment">//0.9</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>限制小数位数</strong>：如果你知道你的计算结果应该具有特定的小数位数，可以限制结果的小数位数，从而减少精度丢失。</p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">2.0</span> - <span class="number">1.1</span>; <span class="comment">// 限制小数位数</span></span><br><span class="line">System.out.printf(<span class="string">&quot;%.2f%n&quot;</span>, result);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>尽量避免浮点数比较</strong>：避免使用&#x3D;&#x3D;或!&#x3D;运算符来来比较两个浮点数，因为浮点数的精度问题可能导致不准确的结果。</p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">2.0</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">1.1</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">epsilon</span> <span class="operator">=</span> <span class="number">1e-10</span>; <span class="comment">// 定义一个足够小的误差范围</span></span><br><span class="line"><span class="keyword">if</span> (Math.abs(num1 - num2) &lt; epsilon) &#123;</span><br><span class="line">    <span class="comment">// 数值相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p> <code>1e-10</code> 表示科学计数法中的一个小数，具体为 0.0000000001。这是一个非常接近零的小数，通常用于表示非常小的数值或误差范围，以在浮点数比较中避免精度问题。</p>
</li>
</ol>
<!-- More info: [Deployment](https://hexo.io/docs/one-command-deployment.html) -->]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL-表管理</title>
    <url>/2023/11/09/Mysql/Basic/MYSQL-%E8%A1%A8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="管理表"><a href="#管理表" class="headerlink" title="管理表"></a>管理表</h2><p><strong>查看表结构：</strong></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESC</span> myemp1;  #查看表结构</span><br></pre></td></tr></table></figure></div>

<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>语法格式：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 表名(</span><br><span class="line">    字段<span class="number">1</span>, 数据类型 [约束条件] [默认值],</span><br><span class="line">    字段<span class="number">2</span>, 数据类型 [约束条件] [默认值],</span><br><span class="line">    字段<span class="number">3</span>, 数据类型 [约束条件] [默认值],</span><br><span class="line">    ……</span><br><span class="line">    [表约束条件]</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>假设我们要创建一个名为 <strong><code>users</code></strong> 的表格，包含 <strong><code>id</code><strong>、</strong><code>username</code></strong> 和 <strong><code>email</code></strong> 列：</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,  <span class="operator">/</span><span class="operator">/</span>设置为主键、自增长</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,      <span class="operator">/</span><span class="operator">/</span>非空约束</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>  <span class="operator">/</span><span class="operator">/</span>唯一性约束</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>基于现有的表进行创建（复制）</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> myemp2</span><br><span class="line">	<span class="keyword">AS</span></span><br><span class="line">	<span class="keyword">SELECT</span> employee_id,last_name,salary</span><br><span class="line">	<span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">#说明<span class="number">1</span>：查询语句中的别名可以作为新表的字段名称</span><br><span class="line">#说明<span class="number">2</span>：查询语句可以结构丰富</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> myemp3</span><br><span class="line">	<span class="keyword">AS</span> </span><br><span class="line">	<span class="keyword">SELECT</span> e.employee_id emp_id,e.last_name emp_name,d.department_name </span><br><span class="line">	<span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line">	<span class="keyword">ON</span> e.department_id<span class="operator">=</span>d.department_id;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><p>基本语法：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 【<span class="keyword">COLUMN</span>】 字段名 字段类型 【<span class="keyword">FIRST</span><span class="operator">|</span>AFTER 字段名】;</span><br></pre></td></tr></table></figure></div>

<h3 id="添加属性"><a href="#添加属性" class="headerlink" title="添加属性"></a>添加属性</h3><ol>
<li><p><strong>添加属性到末尾</strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> myemp1</span><br><span class="line">	<span class="keyword">ADD</span> salary <span class="keyword">DOUBLE</span>(<span class="number">10</span>,<span class="number">2</span>)  #一共<span class="number">10</span>位<span class="operator">=</span>整数位<span class="number">8</span>位<span class="operator">+</span>小数位<span class="number">2</span>位，默认添加到表的最后一个字段</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>插入属性首位</strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> myemp1</span><br><span class="line">	<span class="keyword">ADD</span> phone_number <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">FIRST</span>;  #将字段放在首位</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>属性<strong>放在某个字段的前面</strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> myemp1</span><br><span class="line">	<span class="keyword">ADD</span> email <span class="type">VARCHAR</span>(<span class="number">40</span>) AFTER emp_name; #将字段放在emp_name后面</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="修改属性"><a href="#修改属性" class="headerlink" title="修改属性"></a>修改属性</h3><ol>
<li><p><strong><strong>修改列属性（数据类型、约束等）</strong></strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users</span><br><span class="line">MODIFY <span class="keyword">COLUMN</span> email <span class="type">VARCHAR</span>(<span class="number">255</span>);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>重命名列</strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users</span><br><span class="line">CHANGE <span class="keyword">COLUMN</span> username user_name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>删除约束</strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> unique_username</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><ol>
<li><p>使用RENAME</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">RENAME <span class="keyword">TABLE</span> users <span class="keyword">TO</span> new_users</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>使用ALTER，</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users RENAME <span class="keyword">TO</span> new_users;   <span class="operator">/</span><span class="operator">/</span><span class="keyword">TO</span>可以省略</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>增加约束</strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> unique_username <span class="keyword">UNIQUE</span> (user_name);</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><ol>
<li>在MySQL中，当一张数据表<strong>没有与其他任何数据表形成关联关系</strong>时，可以将当前数据表直接删除。</li>
<li><strong>数据</strong>和<strong>创建语句结构</strong>都被删除；</li>
<li>所有相关索引被删除</li>
</ol>
<p>基本语法：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] 数据表<span class="number">1</span> [, 数据表<span class="number">2</span>, …, 数据表n];</span><br></pre></td></tr></table></figure></div>

<h3 id="清空表"><a href="#清空表" class="headerlink" title="清空表"></a>清空表</h3><ol>
<li><p><strong>TRUNCATE</strong></p>
<ol>
<li>删除表中所有的数据</li>
<li><strong>保留创建语句结构</strong></li>
<li>不持支回滚，清空后表数据无法恢复</li>
</ol>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> users;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>DELETE FROM</strong></p>
<ol>
<li>删除表中所有数据；</li>
<li>保留创建的语句结构</li>
<li>设置相关参数，则支持<strong>回滚，表数据可以恢复；</strong></li>
</ol>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit<span class="operator">=</span><span class="literal">FALSE</span>    <span class="operator">/</span><span class="operator">/</span>不自动提交</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> myemp3  #清空表中数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">ROLLBACK</span>  #回滚到最近一次</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p><strong>说明：</strong></p>
<ol>
<li>TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</li>
</ol>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL-聚合函数</title>
    <url>/2023/11/11/Mysql/Basic/MYSQL-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>在 MySQL 中，聚合函数用于对数据进行<strong>汇总</strong>或计算，并返回单个值。</p>
<h2 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h2><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>COUNT(column)</td>
<td>计算行数或满足特定条件的行数</td>
</tr>
<tr>
<td>SUM(column)</td>
<td>计算数值列的总和</td>
</tr>
<tr>
<td>AVG(column)</td>
<td>计算数值列的平均值</td>
</tr>
<tr>
<td>MIN(column)</td>
<td>找到数值列的最小值</td>
</tr>
<tr>
<td>MAX(column)</td>
<td>找到数值列的最大值</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>COUNT()</strong></p>
<p> COUNT()函数用于计算行的数量或满足特定条件的行数。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(column_name) <span class="keyword">FROM</span> your_table;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>SUM()</strong></p>
<p> SUM()函数用于计算数值列的总和。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(column_name) <span class="keyword">FROM</span> your_table;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>AVG()</strong></p>
<p> AVG()函数用于计算数值列的平均值。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(column_name) <span class="keyword">FROM</span> your_table;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>MIN()</strong></p>
<p> MIN()函数用于找到数值列的最小值。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(column_name) <span class="keyword">FROM</span> your_table;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>MAX()</strong></p>
<p> MAX()函数用于找到数值列的最大值。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(column_name) <span class="keyword">FROM</span> your_table;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h2><p>GROUP BY 语句用于将结果集按照一个或多个列进行分组。它通常与聚合函数（如 COUNT()、SUM()、AVG() 等）一起使用，以对每个分组进行汇总或计算。</p>
<p><strong>基本语法：</strong></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, AGGREGATE_FUNCTION(column3)</span><br><span class="line"><span class="keyword">FROM</span> your_table</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1, column2;</span><br></pre></td></tr></table></figure></div>

<p><strong>例子：</strong></p>
<p>假设有一个名为 <strong><code>orders</code></strong> 的表，存储了顾客订单的信息，其中包括 **<code>customer_id</code><strong>（顾客ID）、</strong><code>product_id</code>**（产品ID）和 **<code>amount</code>**（订单数量）。</p>
<table>
<thead>
<tr>
<th>order_id</th>
<th>customer_id</th>
<th>product_id</th>
<th>amount</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>101</td>
<td>201</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>102</td>
<td>202</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>101</td>
<td>203</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>103</td>
<td>201</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>101</td>
<td>202</td>
<td>4</td>
</tr>
</tbody></table>
<ol>
<li><p>现在，我们希望按照顾客ID对订单进行分组，并计算每个顾客的总订单数量。这是一个使用 <strong><code>GROUP BY</code></strong> 的简单示例：</p>
<p> 现在，我们使用 <strong><code>GROUP BY</code></strong> 来按 <strong><code>customer_id</code></strong> 对订单进行分组，使用<code>**SUM()**</code>含糊计算每个顾客的总订单数量：</p>
</li>
</ol>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_orders</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="operator">|</span> customer_id <span class="operator">|</span> total_orders <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">-------------|--------------|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">101</span>         <span class="operator">|</span> <span class="number">7</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">102</span>         <span class="operator">|</span> <span class="number">3</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">103</span>         <span class="operator">|</span> <span class="number">2</span>            <span class="operator">|</span></span><br></pre></td></tr></table></figure></div>

<p>此外，你还可以使用<code>**WITH ROLLUP**</code>在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_orders</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id  <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"> <span class="operator">|</span> customer_id <span class="operator">|</span> total_orders <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">-------------|--------------|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">101</span>         <span class="operator">|</span> <span class="number">7</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">102</span>         <span class="operator">|</span> <span class="number">3</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">103</span>         <span class="operator">|</span> <span class="number">2</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span> <span class="number">12</span>           <span class="operator">|</span></span><br></pre></td></tr></table></figure></div>

<h2 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h2><p><strong><code>HAVING</code></strong> 关键字通常与 <strong><code>GROUP BY</code></strong> 语句结合使用，允许在对分组数据进行筛选时使用条件来过滤结果。</p>
<p>它与 <strong><code>WHERE</code></strong> 关键字类似，但 <strong><code>HAVING</code></strong> 用于筛选基于聚合操作后的结果，而 <strong><code>WHERE</code></strong> 用于筛选原始的行数据。</p>
<p><strong>例子：</strong></p>
<p>假设有一个存储订单信息的表 **<code>orders</code>**，我们想查找订单总金额大于 100 的顾客。我们可以使用 <strong><code>GROUP BY</code></strong> 和 <strong><code>HAVING</code></strong> 来执行这个查询。</p>
<table>
<thead>
<tr>
<th>order_id</th>
<th>customer_id</th>
<th>total_amount</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>101</td>
<td>50</td>
</tr>
<tr>
<td>2</td>
<td>102</td>
<td>120</td>
</tr>
<tr>
<td>3</td>
<td>101</td>
<td>70</td>
</tr>
<tr>
<td>4</td>
<td>103</td>
<td>90</td>
</tr>
<tr>
<td>5</td>
<td>101</td>
<td>40</td>
</tr>
</tbody></table>
<p>现在，我们想找到总金额大于 100 的顾客。我们可以使用 <strong><code>GROUP BY</code></strong> 汇总每个顾客的总金额，然后使用 <strong><code>HAVING</code></strong> 过滤掉总金额不大于 100 的顾客：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">SUM</span>(total_amount) <span class="keyword">AS</span> total_spent</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(total_amount) <span class="operator">&gt;</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="operator">|</span> customer_id <span class="operator">|</span> total_spent <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">-------------|-------------|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">102</span>         <span class="operator">|</span> <span class="number">120</span>         <span class="operator">|</span></span><br></pre></td></tr></table></figure></div>

<h2 id="HAVING-vs-WHERE"><a href="#HAVING-vs-WHERE" class="headerlink" title="HAVING vs WHERE"></a>HAVING vs WHERE</h2><table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>WHERE</td>
<td>先筛选数据再关联，执行效率高</td>
<td>不能使用分组中的计算函数进行筛选</td>
</tr>
<tr>
<td>HAVING</td>
<td>可以使用分组中的计算函数</td>
<td>在最后的结果集中进行筛选，执行效率较低</td>
</tr>
</tbody></table>
<ol>
<li><strong>上述sql语句中，where和HAVING都可以进行过滤，在条件满足的情况下，哪一种的方式更好？</strong><ol>
<li>WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；</li>
<li>HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件。</li>
</ol>
</li>
<li><strong>如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接后筛选</strong><ol>
<li>这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。</li>
<li>HAVING 则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。</li>
</ol>
</li>
</ol>
<p><strong>使用场景：</strong></p>
<ol>
<li>包含分组统计函数的条件用 HAVING，普通条件用 WHERE。</li>
<li>这样，我们就既利用了 WHERE 条件的高效快速，又发挥了 HAVING 可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很大的差别。</li>
</ol>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-什么是类（Class）？</title>
    <url>/2023/11/07/Java/Object-Oriented/Java-Class/</url>
    <content><![CDATA[<h2 id="快速理解"><a href="#快速理解" class="headerlink" title="快速理解"></a>快速理解</h2><p>对象表示具有<strong>状态</strong>和<strong>行为</strong>的实体，例如：一辆汽车是一个对象，汽车的颜色、价格。。</p>
<p>更具体的就是</p>
<ol>
<li><strong>状态（类的属性）</strong>：车的颜色、价格。。</li>
<li><strong>行为（类的方法）</strong>：车可以前进、倒车、加速等行为；</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hosue</span>&#123;</span><br><span class="line">	<span class="comment">//状态</span></span><br><span class="line">    String address;     <span class="comment">//</span></span><br><span class="line">   	String color;</span><br><span class="line">   	<span class="type">double</span> area;</span><br><span class="line">    <span class="comment">//行为</span></span><br><span class="line">   	<span class="keyword">void</span> <span class="title function_">openDoor</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//Write code here</span></span><br><span class="line">   	&#125;</span><br><span class="line">   	<span class="keyword">void</span> <span class="title function_">closeDoor</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//Write code here</span></span><br><span class="line">   	&#125;</span><br><span class="line"> ...</span><br><span class="line"> ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>细节说明：</strong></p>
<ol>
<li>类名必须和文件名相同。</li>
</ol>
<h2 id="构造方法的特点"><a href="#构造方法的特点" class="headerlink" title="构造方法的特点"></a>构造方法的特点</h2><ol>
<li>名字和类名相同</li>
<li>不能被void修饰</li>
<li>可以进行重载，这就是为什么有无参构造和有参构造</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">		String name;</span><br><span class="line">    Animal()&#123;&#125;   <span class="comment">//无参构造</span></span><br><span class="line">		Animal(String name)&#123;  <span class="comment">//有参构造</span></span><br><span class="line">			。。。	</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="类相关操作"><a href="#类相关操作" class="headerlink" title="类相关操作"></a>类相关操作</h2><h3 id="初始化类变量有哪些方式？"><a href="#初始化类变量有哪些方式？" class="headerlink" title="初始化类变量有哪些方式？"></a>初始化类变量有哪些方式？</h3><ol>
<li><p><strong>初始化自定义变量</strong></p>
<p> 在变量定义时直接对变量进行赋值初始化。</p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 在定义时直接初始化变量 x 为 10</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>构造器初始化变量</strong></p>
<p> 在类的构造函数（构造器）中对成员变量进行初始化。构造函数是在创建对象时调用的特殊方法。</p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        y = <span class="number">20</span>; <span class="comment">// 在构造器中初始化变量 y 为 20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>代码块中初始化</strong></p>
<p> 使用初始化块（包括静态初始化块和非静态初始化块）来对成员变量进行初始化。静态初始化块用于静态变量的初始化，非静态初始化块用于实例变量的初始化。</p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnotherClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> z;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非静态初始化块</span></span><br><span class="line">    &#123;</span><br><span class="line">        z = <span class="number">30</span>; <span class="comment">// 在初始化块中初始化变量 z 为 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="获得Class类的JAVA访问方法有几种？并利用主要代码方法简述。"><a href="#获得Class类的JAVA访问方法有几种？并利用主要代码方法简述。" class="headerlink" title="获得Class类的JAVA访问方法有几种？并利用主要代码方法简述。"></a><strong>获得Class类的JAVA访问方法有几种？并利用主要代码方法简述。</strong></h3><ol>
<li><p><strong>通过类的 <code>.class</code> 属性获取：</strong></p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; classObj = MyClass.class; <span class="comment">// MyClass 是你要获取 Class 对象的类名</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>使用 <code>getClass()</code> 方法获取对象的 Class 对象：</strong></p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">Class&lt;?&gt; classObj = obj.getClass();</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>使用 <code>Class.forName()</code> 方法根据类名获取：</strong></p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; classObj = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>); <span class="comment">// 根据类的全限定名获取 Class 对象</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>这种方法都可以用来获取特定类的 <code>Class</code> 对象，但它们的应用场景有所不同。<code>.class</code> 属性和 <code>Class.forName()</code> 用于编译时或者运行时动态地获取类的 <code>Class</code> 对象，而 <code>getClass()</code> 方法通常用于已经存在对象的情况下获取其 <code>Class</code> 对象。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-面向对象核心思想（Object-Oriented）</title>
    <url>/2023/11/07/Java/Object-Oriented/Java-Object-Oriented/</url>
    <content><![CDATA[<h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>方法重写是指子类在继承父类的方法后，重新定义该方法以实现子类特定的行为。</p>
<p>在方法重写中，子类使用与父类相同的方法名、返回类型和参数列表来覆盖（override）父类的方法。</p>
<p>方法重写是实现<strong>运行时多态性（动态多态性）</strong>的一种方式。</p>
<p><strong>特点</strong>：</p>
<ol>
<li>方法重写要求子类方法与父类方法有相同的方法签名（方法名、返回值类型、参数列表）。</li>
<li>子类方法的访问修饰符不能比父类方法更严格。例如，如果父类方法是public，子类方法也必须是public，或者允许范围更大。</li>
<li>子类方法不能使用比父类方法更窄的返回类型。返回类型可以是相同类型或其子类型（协变返回类型）。</li>
<li>子类方法可以使用**<code>@Override</code>**注解来提醒编译器，表明它是对父类方法的重写，但这不是强制性的。</li>
</ol>
<p>如下代码所示：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Some generic sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof! Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上述示例中，<code>Dog</code>类重写了**<code>Animal</code>类的<code>makeSound()</code>**方法，以实现不同的声音行为。</p>
<p>💡 <strong>为什么是static修饰的方法，无法重写？</strong></p>
<ol>
<li>因为static修饰的方法，属于类变量，不是对象实例，无法被重写。</li>
</ol>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>一个类有许多访问修饰符的属性</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">user</span> &#123;</span><br><span class="line">    <span class="comment">//user类的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在外部创建对象时，需要访问该类的属性则需要创建类对象，这个类对象称为对类的<strong>封装</strong>。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span>  <span class="comment">//快速实现getter、setter方法</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span>  <span class="comment">//快速实现有参构造器</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span>   <span class="comment">//快速实现无参构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">user</span> &#123;</span><br><span class="line">    <span class="comment">//user类的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>用户在创建user类的对象后，调用<code>Getter</code>、<code>Setter</code>方法时，不需要关心方法的底层实现原理。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>允许一个类（称为子类或派生类）继承另一个类（称为父类或基类）的属性和方法。</p>
<p>通过继承，子类可以重用父类的代码，并且还可以在子类中添加自己特定的行为和属性，从而实现代码的复用和扩展。</p>
<p>要实现继承，需要使用关键字<code>extends</code>来指定一个类继承另一个类。语法如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span> <span class="keyword">extends</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">    <span class="comment">// 子类特有的属性和方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上述代码中，<code>ChildClass</code>是子类，<code>ParentClass</code>是父类。</p>
<p><strong>特点</strong></p>
<ol>
<li><p><strong>子类通过<code>super</code>关键子访问父类非私有成员</strong></p>
<p> 子类可以访问父类的非私有成员（属性和方法），</p>
<p> 包括公共（public）、受保护（protected）和默认（默认访问修饰符，没有显式声明访问修饰符）访问级别的成员。</p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id=<span class="number">0</span>;  <span class="comment">//子类无法调用</span></span><br><span class="line">    <span class="keyword">public</span> String name=<span class="string">&quot;Parent&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Some generic animal sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">		String dogName=<span class="built_in">super</span>.name;   <span class="comment">//super调用父类的name属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>子类<strong>重写</strong>父类的方法</p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id=<span class="number">0</span>;  <span class="comment">//子类无法调用</span></span><br><span class="line">    <span class="keyword">public</span> String name=<span class="string">&quot;Parent&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Some generic animal sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">		<span class="comment">//重写父类方法</span></span><br><span class="line">		<span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.makeSound();    <span class="comment">//super调用父类的makeSound()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态存在的必要条件</p>
<ol>
<li>有<strong>继承</strong>关系</li>
<li>子类<strong>重写</strong>父类的方法</li>
<li>父类引用指向子类</li>
</ol>
<p>如下代码所示：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.printfln(<span class="string">&quot;调用了父类方法&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;           <span class="comment">//重写了父类的方法</span></span><br><span class="line">		System.out.printfln(<span class="string">&quot;调用了子类方法&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person person=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person.test();             </span><br><span class="line"></span><br><span class="line">Person person=<span class="keyword">new</span> <span class="title class_">Student</span>();  <span class="comment">//父类引用指向子类，这就是多态</span></span><br><span class="line">person.test();                <span class="comment">//此时调用的是子类的方法 </span></span><br><span class="line"></span><br><span class="line">person.hello();               <span class="comment">//此时就会抛出异常，因为hello()是子类独有的方法，父类无法调用         </span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="string">&quot;调用了父类方法&quot;</span></span><br><span class="line"><span class="string">&quot;调用了子类方法&quot;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>特点</strong></p>
<ol>
<li><strong>父类只能调用子类中重写的方法，无法调用子类中独有的方法</strong>；</li>
<li>父类调用方法的过程：先在子类中查找重写的方法，如果该方法没有被重写，则调用父类的方法。</li>
</ol>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类（Abstract Class）是面向对象编程中的一个重要概念，它允许创建具有共享特征和行为的一组类，并为这些类提供一个通用的基类。</p>
<p>抽象类存在的<strong>目的</strong>主要是作为其他类的<strong>父类</strong>。</p>
<p>以下是关于抽象类的详细介绍：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Parent</span>&#123;   <span class="comment">//抽象类</span></span><br><span class="line">    String name=<span class="string">&quot;rainbow&quot;</span>;               <span class="comment">//属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃东西&quot;</span>);   <span class="comment">//普通方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>;   <span class="comment">//抽象方法没有方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>如果一个类中存在被<code>abstrct</code>修饰的方法（抽象方法），则该类必须为抽象类；</li>
<li>抽象方法不能有方法体<code>&#123;&#125;</code>；</li>
<li>抽象类也是一个类，有属性、构造器、方法；</li>
<li>抽象类中可以没有抽象方法；</li>
<li><strong>抽象类不能被实例化</strong>：因为抽象类中包含未实现的抽象方法，无法提供完整的对象行为；</li>
<li><strong>继承</strong>：其他类可以继承抽象类，子类必须实现抽象类中的抽象方法，除非子类也为<code>abstrct</code>类；</li>
<li>抽象方法不能被private、final、static关键字修饰；</li>
<li><strong>模板</strong>：抽象类通常在设计模式中应用较多，抽象类可以用于实现<strong>模板</strong>方法模式，其中抽象类定义了一个算法的骨架，而将某些步骤的具体实现留给子类。</li>
</ol>
<h3 id="应用场景-模板模式"><a href="#应用场景-模板模式" class="headerlink" title="应用场景-模板模式"></a><strong>应用场景-模板模式</strong></h3><p><strong>场景引入</strong>：</p>
<ol>
<li>现在有多个类，每个类完成的功能不同；</li>
<li>要求能过得到各自的完成时间；</li>
<li>请编写实现</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();   <span class="comment">//开始时间</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">//A类的主要任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">800000</span>; i++) &#123;</span><br><span class="line">            num += i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();   <span class="comment">//结束时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A执行了&quot;</span> + (endTime - startTime) + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();   <span class="comment">//开始时间</span></span><br><span class="line">	</span><br><span class="line">				<span class="comment">//B类的主要任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">600000</span>; i++) &#123; </span><br><span class="line">            num =num * i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();   <span class="comment">//结束时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;B执行了&quot;</span> + (endTime - startTime) + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上述代码存在的问题：</p>
<ol>
<li><strong>代码冗余</strong>：A和B类中计算时间的代码重复，如果有n个类，那么大大增加了不必要的代码量；</li>
</ol>
<p>为了解决这个问题，我们可以使用抽象类定义一个计算任务执行时间的模板，避免代码的冗余</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplateMode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.calculateTime();   <span class="comment">//直接调用父类的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.calculateTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">calculateTimeTemplate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span>;    <span class="comment">//定义抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();   <span class="comment">//开始时间</span></span><br><span class="line">        </span><br><span class="line">				job();      <span class="comment">//各个类执行的任务</span></span><br><span class="line">	</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();   <span class="comment">//结束时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;任务执行了&quot;</span> + (endTime - startTime) + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//各个类专注与执行自己的任务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">calculateTimeTemplate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">800000</span>; i++) &#123;</span><br><span class="line">            num += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">calculateTimeTemplate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">600000</span>; i++) &#123;</span><br><span class="line">            num += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><code>calculateTimeTemplate</code> 抽象类定义了一个抽象方法 <code>job()</code>，这个方法是模板方法模式中的抽象部分，要求具体子类实现。</li>
<li><code>calculateTimeTemplate</code> 抽象类中的 <strong><code>calculateTime()</code></strong> 方法是一个模板方法，它包含了任务执行的计时逻辑。它记录了任务执行的时间。</li>
<li><code>A</code> 类和 <code>B</code> 类都<strong>继承</strong>自 <code>calculateTimeTemplate</code> 抽象类，并实现了 <code>job()</code> 方法，两个类都专注于执行自己的任务。</li>
</ol>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在面向对象编程中，接口（Interface）是一种抽象的类别，它定义了一组方法的声明，但没有提供这些方法的具体实现。</p>
<p>接口用于描述类应该具备的行为，以及这些行为的方法签名，但不包含方法体。下面是有关接口的主要概念和特点：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//2、接口无法实例化，而是通过多态调用方法</span></span><br><span class="line">        <span class="type">USB</span> <span class="variable">usb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        usb.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;   <span class="comment">//默认是public static final修饰</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义抽象方法，可以省略public abstract</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">    <span class="comment">//1、子类必须实现接口的抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机开始工作。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><strong>方法申明</strong>：每个方法都是 public 修饰的抽象方法，可以省略<code>public abstract</code>关键字。</li>
<li><strong>属性</strong>：接口可以定义属性，<code>int num = 10</code>，默认是public\ static\ final修饰；</li>
<li><strong>实现</strong>：子类必须实现接口中的所有抽象方法；</li>
<li><strong>多态</strong>：允许通过接口类型的引用调用子类重写的方法；</li>
<li><strong>多实现</strong>：允许子类同时实现多个接口；</li>
<li><strong>无法被实例化</strong>。</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>场景引入</strong>：</p>
<ol>
<li><p>现在客户端有时需要连接不同的数据库，但是每个数据库的驱动链接方式都不同，如下图所示：</p>
 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/37.png"
                      alt="图片描述" width="400"
                >
 </li>
<li><p>用户如果需要连接不同的数据库就要创建不同的对象，不方便后期代码的维护。</p>
</li>
</ol>
<p><strong>解决方法：</strong></p>
<ol>
<li>此时就可以使用一个接口，统一管理数据库的连接。</li>
<li>用户只需要传入数据库对象，接口可以自动判断需要连接哪个数据库，如下图所示</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/38.png"
                      alt="图片描述" width="400"
                >


<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DBconnect</span> <span class="variable">dBconnect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mysql</span>();   <span class="comment">//向上转型</span></span><br><span class="line">        dBconnect.connectDB();</span><br><span class="line"></span><br><span class="line">        <span class="type">DBconnect</span> <span class="variable">dBconnect1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MongoDB</span>();  </span><br><span class="line">        dBconnect1.connectDB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建连接数据库接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DBconnect</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">connectDB</span><span class="params">()</span>;   <span class="comment">//定义链接数据库的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mysql</span> <span class="keyword">implements</span> <span class="title class_">DBconnect</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connectDB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接MySQL&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MongoDB</span> <span class="keyword">implements</span> <span class="title class_">DBconnect</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connectDB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接MongoDB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">输出:</span><br><span class="line">连接MySQL</span><br><span class="line">连接MongoDB</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-什么是方法（Methods）？</title>
    <url>/2023/11/07/Java/Basic/Java-Methods/</url>
    <content><![CDATA[<h2 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h2><p>我们可以按照方法的返回值和参数类型将方法分为下面这几种：</p>
<ol>
<li><p><strong>无参数无返回值方法</strong></p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面这个方法也没有返回值，虽然用到了 return</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 表示结束方法的执行,下方的输出语句不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>有参数无返回值方法</strong></p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(Parameter <span class="number">1</span>, ..., Parameter n)</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>无参数有返回值方法</strong></p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>有返回值有参数方法</strong></p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f4</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>静态方法（Static Methods）是与类本身相关联的方法，而不是与类的实例（对象）相关联。它们属于类，而不是属于类的实例。</p>
<p>以下是关于静态方法的一些重要特点：</p>
<ol>
<li><strong>定义静态方法：</strong> <ol>
<li>静态方法的定义在方法签名中通常包括 <code>static</code> 关键字。</li>
<li>它们可以访问类级别的成员变量和其他静态方法，<strong>但不能访问实例级别的成员变量或方法</strong>。</li>
</ol>
</li>
<li><strong>无法访问实例变量：</strong><ol>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。</li>
<li>而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>
</ol>
</li>
</ol>
<h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>方法重写（Method Overriding）是面向对象编程中的一种重要概念，它允许子类在继承自父类的方法的基础上重新定义（覆盖）这些方法，以满足子类的特定需求。方法重写是多态性的一个重要示例，它允许在运行时动态地选择要执行的方法，具体的方法取决于对象的类型。</p>
<p>以下是方法重写的一些关键规则和注意事项：</p>
<ol>
<li><strong>方法重写的规则：</strong><ol>
<li><strong>方法的名称</strong>、<strong>参数列表</strong>和<strong>返回类型</strong>必须与父类中的被重写方法相同。</li>
<li>访问修饰符可以相同或更宽松，但不能更严格（例如，父类的方法是 <code>public</code>，子类的可以是 <code>public</code> 或 <code>protected</code>，但不能是 <code>private</code>）。</li>
<li>子类方法不能抛出比父类方法更多的已检查异常。</li>
<li>子类方法不能缩小父类方法的访问权限。</li>
</ol>
</li>
<li><strong>@Override 注解</strong>：为了明确标识方法是重写的，可以使用 <code>@Override</code> 注解来标记子类中的重写方法。这是可选的，但推荐使用。</li>
</ol>
<p><strong>Code：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        animal.makeSound(); <span class="comment">// 输出：&quot;Dog barks&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上述示例中，<code>Dog</code> 类重写了 <code>Animal</code> 类中的 <code>makeSound</code> 方法。即使通过 <code>Animal</code> 类的引用创建了一个 <code>Dog</code> 对象，但在运行时会选择执行 <code>Dog</code> 类中的重写方法，因为它是对象的实际类型。这是方法重写的一个典型示例。</p>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>方法重载是指在同一个类中定义多个相同方法名，但是参数列表不同的方法。</p>
<p><strong>方法名相同</strong></p>
<ol>
<li><strong>参数个数</strong>可以不同</li>
<li><strong>参数类型</strong>可以不同</li>
<li><strong>方法修饰符</strong>可以不同，但是不作为重载的参考。</li>
</ol>
<p>方法重载是实现<strong>编译时多态性</strong>的一种方法。</p>
<p><strong>特点</strong>:</p>
<ol>
<li>方法重载要求方法名相同但参数列表不同。</li>
<li>返回类型可以相同也可以不同，但方法重载不能仅根据返回类型来区分，否则JVM无法确定调用哪个方法。</li>
<li>方法重载可以在同一个类中进行，也可以在父类和子类之间进行。</li>
<li>方法重载与方法的返回值无关，<strong>仅与参数相关</strong>。</li>
</ol>
<p><strong>Code：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MathOperations</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Object类</title>
    <url>/2023/11/07/Java/Object-Oriented/Java-Object/</url>
    <content><![CDATA[<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>Object类是一个特殊的类，是所有类的父类。主要提供了一下几个方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals() 的区别"></a><strong><strong>&#x3D;&#x3D; 和 equals() 的区别</strong></strong></h2><p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p>
<ol>
<li>对于<strong>基本数据类型</strong>来说，<code>==</code> 比较的是<strong>内容</strong>。</li>
<li>对于<strong>引用数据类型</strong>来说，<code>==</code> 比较的是对象的<strong>内存地址</strong>。</li>
</ol>
<p><code>equals()</code> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。</p>
<p><code>equals()</code> 方法存在两种使用情况：</p>
<ol>
<li><strong>类没有重写了equals()方法</strong>：比较两个对象的内存地址。</li>
<li><strong>类重写了equals()方法</strong>：一般都会重写该方法用于比较对象的属性<strong>。</strong></li>
</ol>
<p><strong>String</strong>类型，默认重写了<code>equls()</code>方法，使用时比较的是内容。</p>
<h2 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode()方法"></a>hashCode()方法</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/39.png"
                      alt="Alt text"
                ></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>两个引用，如果指向同一个对象，则哈希值相同；</li>
<li>两个引用，如果指向不是同一个对象，则哈希值不相同；</li>
<li>哈希值并不是内存地址，哈希值是使用对象的内存地址计算哈希码。</li>
</ol>
<p>💡 <strong>为什么有<code>hashCode()</code>方法？</strong></p>
<ol>
<li><strong>快速查找和存储</strong>：通过使用哈希码，可以将对象分散到数组中的不同位置，从而实现高效的数据访问</li>
<li><strong>性能优化</strong>：使用哈希码可以提高集合和映射操作的性能。</li>
</ol>
<h2 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h2><p>在Java中，<code>Object</code>类的<code>toString()</code>方法用于返回表示对象的字符串。<br>默认情况下，<code>toString()</code>方法返回一个字符串，其中包含了<strong>对象的类名</strong>和<strong>对象的哈希码的十六进制</strong>表示。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>同时，我也也可以重写<code>toString()</code>方法来输出自定义的内容。</p>
<h2 id="Clone-方法"><a href="#Clone-方法" class="headerlink" title="Clone()方法"></a>Clone()方法</h2><p><code>clone()</code> 方法主要用于创建对象的拷贝，但在 Java 中存在浅拷贝和深拷贝两种不同的拷贝方式，而引用拷贝通常是指浅拷贝中的一种情况。</p>
<p>让我们解释这三种拷贝方式：</p>
<ol>
<li><p><strong>深拷贝</strong>：完全复制整个对象，包括对象中所包含的引用对象。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/40.png"
                      alt="Alt text"
                ></p>
</li>
<li><p><strong>浅拷贝</strong>：在堆上创建一个新对象，如果内部存在引用类型的对象，则拷贝对象和原对象共用同一个内部引用对象。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/41.png"
                      alt="Alt text"
                ></p>
</li>
<li><p><strong>引用拷贝</strong>：原对象和拷贝对象的内部引用对象相同。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/42.png"
                      alt="Alt text"
                ></p>
</li>
</ol>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>在Java中，要执行浅拷贝，可以使用以下方法：</p>
<ol>
<li><p><strong>使用 <code>clone()</code> 方法</strong>：某些类实现了 <code>Cloneable</code> 接口，可以通过 重写<code>clone()</code> 方法来创建对象的浅拷贝。这包括数组和一些标准类，如 <code>String</code>。</p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 clone() 方法进行浅拷贝</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MyClass <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (MyClass) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>手动实现浅拷贝：你可以编写自定义代码来创建一个新对象并复制原始对象的字段值。</p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手动实现浅拷贝</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> MyClass <span class="title function_">shallowCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        copy.field1 = <span class="built_in">this</span>.field1;</span><br><span class="line">        copy.field2 = <span class="built_in">this</span>.field2;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>在 Java 中，深拷贝是一种复制对象，包括对象本身及其所有嵌套对象的所有属性。</p>
<p>深拷贝的目的是创建一个新的对象，使其在内存中独立于原始对象，而不共享引用对象。</p>
<p>在 Java 中，实现深拷贝的方法通常包括以下几种：</p>
<ol>
<li><p><strong>使用序列化和反序列化</strong>：通过将对象序列化为字节数组，然后反序列化为新对象，可以实现深拷贝。这需要确保所有对象及其嵌套对象都是可序列化的。</p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCopyExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">deepCopy</span><span class="params">(T object)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">            out.writeObject(object);</span><br><span class="line">            out.flush();</span><br><span class="line"></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">            <span class="keyword">return</span> (T) in.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p> 请注意，要使对象可序列化，它必须实现 <code>Serializable</code> 接口。</p>
</li>
<li><p><strong>使用第三方库</strong>：Java中有一些第三方库，如 Apache Commons Lang 或 Gson，提供了深拷贝方法。这些库通常提供了更简单的方式来实现深拷贝。</p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.SerializationUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCopyExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">deepCopy</span><span class="params">(T object)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SerializationUtils.clone(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>自定义递归复制</strong>：手动编写递归方法，遍历对象及其嵌套对象的属性，并创建新的对象进行复制。</p>
 <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCopyExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyObject</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">        <span class="keyword">private</span> MyObject nestedObject;   <span class="comment">//引用类型对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Constructor, getters, and setters</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MyObject <span class="title function_">deepCopy</span><span class="params">(MyObject object)</span> &#123;</span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line">        copy.setValue(object.getValue());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (object.getNestedObject() != <span class="literal">null</span>) &#123;</span><br><span class="line">            copy.setNestedObject(deepCopy(object.getNestedObject()));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-变量（Variable）</title>
    <url>/2023/11/07/Java/Basic/Java-Variable/</url>
    <content><![CDATA[<h2 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h2><p>成员变量（Instance Variables）和局部变量（Local Variables）是在编程中两种不同的变量类型，它们在作用域、生命周期和用途上有很大的区别。</p>
<ol>
<li><strong>访问修饰符</strong><ol>
<li>成员变量：可以被（public、private、protected、default）修饰</li>
<li>局部变量：只能在定义的范围内访问，没有访问修饰符</li>
</ol>
</li>
<li><strong>存储方式</strong><ol>
<li>成员变量：如果是static修饰属于类信息，则存储在方法区，反之，是属于实例，存储在堆中。</li>
<li>局部变量：存储在虚拟栈。</li>
</ol>
</li>
<li><strong>生命周期</strong><ol>
<li>成员变量：是对象的一部分，随着对象的创建而存在。</li>
<li>局部变量：随着方法的调用而存在，随着方法的调用结束而消亡。</li>
</ol>
</li>
<li><strong>初始化</strong><ol>
<li>成员变量：成员变量可以有默认初始值，如果没有显式初始化，它们将具有默认值（如0、false或null，具体取决于数据类型）。</li>
<li>局部变量：局部变量必须显式初始化，否则编译器将报错。它们不具有默认初始值。</li>
</ol>
</li>
</ol>
<p><strong>成员变量与局部变量代码示例：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableExample</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;     <span class="comment">//存储在堆</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> id;       <span class="comment">//存储在方法区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法中的局部变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;                <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// 栈中分配的局部变量</span></span><br><span class="line">        System.out.println(num1);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><p>静态变量也就是被<code>static</code>关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。</p>
<p>也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。</p>
<p>以下是关于静态变量的一些重要特点：</p>
<ol>
<li><strong>访问方式</strong>：静态变量可以通过类名来访问，而不需要创建类的实例。例如，<code>ClassName.staticVariable</code>。</li>
<li>静态变量会被 <code>final</code> 关键字修饰成为常量。</li>
<li><strong>静态代码块：</strong>也属于静态变量的一部分，程序运行过程中只会被分配一次内存，只执行一次。</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">staticVariable</span> <span class="operator">=</span> <span class="number">42</span>; <span class="comment">// 静态变量的声明和初始化</span></span><br><span class="line">    </span><br><span class="line">		<span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        staticVariable = <span class="number">100</span>;   <span class="comment">// 静态块中的初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL-运算符</title>
    <url>/2023/11/10/Mysql/Basic/MYSQL-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>在 MySQL 中，运算符主要用于执行各种算术、逻辑和比较操作。以下是 MySQL 中常用的运算符和它们的基本操作：</p>
<h2 id="算法运算符"><a href="#算法运算符" class="headerlink" title="算法运算符"></a>算法运算符</h2><ol>
<li><p><strong>加法</strong>：执行加法操作。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 <span class="operator">+</span> column2 <span class="keyword">AS</span> sum_result <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>减法</strong></p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 <span class="operator">-</span> column2 <span class="keyword">AS</span> difference <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<ul>
<li><p><strong>乘法</strong></p>
  <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 <span class="operator">*</span> column2 <span class="keyword">AS</span> product <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>除法</strong></p>
  <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 <span class="operator">/</span> column2 <span class="keyword">AS</span> division_result <span class="keyword">FROM</span> table_nam</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>**取模 <code>%</code>**：获取除法的余数。</p>
  <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 <span class="operator">%</span> column2 <span class="keyword">AS</span> modulo_result <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AND、&amp;&amp;</td>
<td>和</td>
</tr>
<tr>
<td>OR 、</td>
<td></td>
</tr>
<tr>
<td>NOT、!</td>
<td>非</td>
</tr>
</tbody></table>
<ol>
<li><p>**与 <code>AND</code> 或 <code>&amp;&amp;</code>**：逻辑与运算符。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">WHERE</span> condition1 <span class="keyword">AND</span> condition2;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>**或 <code>OR</code> 或 <code>||</code>**：逻辑或运算符。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> condition1 <span class="keyword">OR</span> condition2;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>**非 <code>NOT</code> 或 <code>!</code>**：逻辑非运算符。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>等于</td>
</tr>
<tr>
<td>!&#x3D;、&lt;&gt;</td>
<td>不相等</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&gt; &#x3D;</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt; &#x3D;</td>
<td>小于等于</td>
</tr>
</tbody></table>
<ol>
<li><p>**等于 <code>=</code>**：检查两个值是否相等。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column1 <span class="operator">=</span> <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>**不等于 <code>!=</code> 或 <code>&lt;&gt;</code>**：检查两个值是否不相等。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column1 <span class="operator">&lt;&gt;</span> <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>**大于 <code>&gt;</code>**：检查左侧值是否大于右侧值。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column1 <span class="operator">&gt;</span> <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>**小于 <code>&lt;</code>**：检查左侧值是否小于右侧值。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column1 <span class="operator">&lt;</span> <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>**大于等于 <code>&gt;=</code>**：检查左侧值是否大于或等于右侧值。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column1 <span class="operator">&gt;=</span> <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>**小于等于 <code>&lt;=</code>**：检查左侧值是否小于或等于右侧值。</p>
 <div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column1 <span class="operator">&lt;=</span> <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><h3 id="BETWEEN-AND"><a href="#BETWEEN-AND" class="headerlink" title="BETWEEN AND"></a><strong>BETWEEN AND</strong></h3><p>你可以使用 <strong><code>NOT</code></strong> 关键字来取反 <strong><code>BETWEEN</code></strong> 运算符的条件，以选择不在指定范围内的值。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> price <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">AND</span> <span class="number">50</span>;</span><br></pre></td></tr></table></figure></div>

<p>这将选择价格不在 10 到 50 范围内的产品。</p>
<h3 id="IN"><a href="#IN" class="headerlink" title="IN"></a><strong>IN</strong></h3><p><strong><code>IN</code></strong> 运算符用于在一组值中进行匹配，类似于多个 OR 条件的简写形式。</p>
<p><strong>基本语法</strong></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">IN</span> (value1, value2, ...);</span><br></pre></td></tr></table></figure></div>

<p><strong>例子</strong></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> category <span class="keyword">IN</span> (<span class="string">&#x27;Electronics&#x27;</span>, <span class="string">&#x27;Clothing&#x27;</span>, <span class="string">&#x27;Books&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<p>这将从 <strong><code>products</code></strong> 表中选择类别为 ‘Electronics’、’Clothing’ 或 ‘Books’ 的产品。</p>
<h3 id="NOT-IN"><a href="#NOT-IN" class="headerlink" title="NOT IN"></a><strong>NOT IN</strong></h3><p><strong><code>NOT IN</code></strong> 与 <strong><code>IN</code></strong> 相反，用于从一组值之外进行筛选。</p>
<p><strong>基本语法</strong></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">NOT</span> <span class="keyword">IN</span> (value1, value2, ...);</span><br></pre></td></tr></table></figure></div>

<p><strong>例子</strong></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> category <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;Furniture&#x27;</span>, <span class="string">&#x27;Toys&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<p>这将从 <strong><code>products</code></strong> 表中选择类别不是 ‘Furniture’ 或 ‘Toys’ 的产品。</p>
<h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a><strong>LIKE</strong></h3><p><strong><code>LIKE</code></strong> 运算符用于基于模式匹配来检索匹配特定模式的值。</p>
<p>基本语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">LIKE</span> <span class="keyword">pattern</span>;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><strong><code>pattern</code></strong> 是要匹配的模式。通常使用 <strong><code>%</code></strong> 表示零个或多个字符，或使用 <strong><code>_</code></strong> 表示单个字符。</li>
</ol>
<p><strong>例子</strong></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> username <span class="keyword">LIKE</span> <span class="string">&#x27;a%&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p>这将从 <strong><code>users</code></strong> 表中选择用户名以字母 ‘a’ 开头的所有用户。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> email <span class="keyword">LIKE</span> <span class="string">&#x27;%@gmail.com&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p>这将从 <strong><code>users</code></strong> 表中选择邮箱地址以 ‘@gmail.com’ 结尾的所有用户。</p>
]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
</search>
